# Введение в основы

### 1.1 О Go

Go представляет компилируемый статически типизированный язык программирования от компании Google. Язык Go предназначен для создания различного рода приложений, но прежде всего это веб-сервисы и клиент-серверные приложения. Хотя также язык обладает возможностями по работе с графикой, низкоуровневыми возможностями и т.д.

Работа над языком Go началась в 2007 в недрах компании Google. Одним из авторов является Кен Томпсон, который, к слову, является и одним из авторов языка Си (наряду с Денисом Ритчи). 10 ноября 2009 года язык был анонсирован, а в марте 2012 года вышла версия 1.0. При этом язык продолжает развиваться.

Язык Go развивается как open source, то есть представляет проект с открытым исходным кодом, и все его коды и компилятор можно найти и использовать бесплатно. Официальный сайт проекта - https://go.dev/, где можно найти много полезной информации о языке.

Go является кроссплатформенным, он позволяет создавать программы под различные операционные системы - Windows, Mac OS, Linux, FreeBSD, Android и т.д. Код обладает переносимостью: программы, написанные для одной из этих операционных систем, могут быть легко с перекомпиляцией перенесены на другую ОС.

#### Почему стоит изучать язык Go

Go проектировался с прицелом на эффективное масштабирование, благодаря чему его можно использовать для создания очень больших приложений и компиляции даже очень больших программ за секунды на единственном компьютере. Молниеносная скорость компиляции обеспечивается отчасти простотой синтаксического анализа программ на этом языке, но главным образом благодаря особенностям управления зависимостями.

Благодаря высокой скорости компиляции программ на языке Go появляется возможность использовать этот язык в областях, где обычно применяются языки сценариев.

Язык Go имеет очень простой и понятный синтаксис, в котором отсутствуют сложные и замысловатые конструкции, характерные для более старых языков, таких как C++ (появившегося в 1983 году) или Java (появившегося в 1995 году). И относится к категории языков со строгой статической типизацией, что многими программистами считается важным условием для разработки крупных программ. Однако система типов данных в языке Go не слишком обременительна благодаря поддержке синтаксиса объявления переменных одновременно с их инициализацией (когда компилятор определяет тип автоматически, избавляя от необходимости явно указывать его) и наличию мощного и удобного механизма динамической типизации.

Все сложности, связанные с учетом ресурсов в языке Go, берут на себя компилятор и среда выполнения. Для управления памятью в Go имеется механизм сборки мусора, что избавляет от необходимости использовать «интеллектуальные» указатели или освобождать память вручную. А поддержка параллелизма в языке Go реализована в форме механизма взаимодействующих последовательных процессов (Communicating Sequential Processes, CSP), основанного на идеях специалиста в области теории вычислительных машин и систем Чарльза Энтони Ричарда Хоара (C. A. R. Hoare), благодаря которому во многих многопоточных программах на языке Go вообще отпадает необходимость блокировать доступ к ресурсам. Кроме того, в языке Go имеются так называемые go-подпрограммы (goroutines) – очень легковесные процессы, которых можно создать великое множество. Выполнение этих процессов автоматически будет распределяться по доступным процессорам и ядрам, что обеспечивает возможность более тонкого деления программ на параллельно выполняющиеся задачи, чем это позволяют другие языки программирования, основанные на потоках выполнения. Фактически поддержка параллелизма в языке Go реализована настолько просто и естественно, что при переносе однопоточных программ на язык Go часто обнаруживается возможность параллельного выполнения нескольких задач, ведущая к увеличению скорости  выполнения и более оптимальному использованию машинных ресурсов.

Go – практичный язык, где во главу угла поставлены эффективность программ и удобство программиста. Например,  встроенные и определяемые пользователем типы данных в языке Go существенно отличаются – операции с первыми из них могут быть значительно оптимизированы, что невозможно для последних. В Go имеются также два встроенных фундаментальных типа коллекций: срезы (slices) (фактически ссылки на массивы переменной длины) и отображения (maps) (словари, или хеши пар ключ/значение). Коллекции этих типов высокооптимизированы и с успехом могут использоваться для решения самых разных задач. В языке Go также поддерживаются указатели (это действительно компилируемый язык программирования – в нем отсутствует какая-либо виртуальная машина, снижающая производительность), что позволяет с непринужденностью создавать собственные, весьма сложные типы данных, такие как сбалансированные двоичные деревья.

В то время как C поддерживает только процедурное программирование, а Java вынуждает программистов писать все программы в объектно-ориентированном стиле, Go позволяет использовать парадигму, наиболее подходящую для конкретной задачи. Go можно использовать как исключительно процедурный язык программирования, но он также обладает поддержкой объектно-ориентированного стиля программирования. Однако, как будет показано далее в курсе, реализация объектно-ориентированной парадигмы в Go радикально отличается от реализации этой же парадигмы в таких языках, как C++, Java или Python. Она намного проще в использовании и значительно гибче.

#### Запуск программы на Go

Запускать можно через терминал/командную строку:
```go
go run main.go
```

Команда выше только выполнит программу. Если же нужно скомпилировать программу, то-есть получить готовый бинарник для запуска на машинах без Go (для windows это будет .exe) - нужно выполнить следующую команду:
```go
go build main.go
```

### 1.2 Первая программа

Традиционно первая программа, с которой начинается изучение любого языка программирования, называется «Hello World» — эта программа просто выводит в консоль строку Hello World.
```go
package main


import "fmt"


func main() {
    fmt.Println("Hello, Go!")
}
```

**package main** - объявление нового пакета. В любом проекте должен быть обязательно пакет main. Запуск программы начинается именно с этого пакета.

Далее следует **пустая строка**. Go не обращает на подобные строки внимания, но их используют, чтобы облегчить чтение программы.

**import "fmt"** - импортирование пакета ввода/вывода.

**func main(){}** - объявление функции c названием "main". Имя main является особенным, эта функция будет вызываться сама при запуске программы. Эта функция тоже обязательная в программе, с неё начинает работать код. 

**fmt.Println("Hello, Go!")**  - здесь вводится то, что нам нужно, используя встроенную функцию Println() из пакета fmt.

### 1.3 Типы данных

Go - это язык программирования со статической типизацией. Это означает, что переменные всегда имеют определенный тип и этот тип нельзя изменить.

#### Числа

В Go есть несколько различных типов для представления чисел. Разделим числа на два различных класса: целые числа и числа с плавающей точкой.

##### Целые числа

Целые числа - это числа без дробной части.

В Go существуют следующие типы целых чисел: `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32` и `int64`. 8, 16, 32 и 64 говорит нам, сколько бит использует каждый тип. `uint` означает "unsigned integer" (беззнаковое целое), в то время как `int` означает "signed integer" (знаковое целое). Беззнаковое целое может принимать только положительные значения (или ноль).

Определение в Go | Тип данных | Значение
-- | -- | --
uint8 |	Беззнаковые 8-битные целые числа | от 0 до 255
uint16 | Беззнаковые 16-битные целые числа | от 0 до 65535
uint32 | Беззнаковые 32-битные целые числа | от 0 до 4294967295
uint64 | Беззнаковые 64-битные целые числа | от 0 до 18446744073709551615
int8 | Знаковые 8-битные целые числа | от -128 до 127
int16 | Знаковые 16-битные целые числа | от -32768 до 32767
int32 | Знаковые 32-битные целые числа | от -2147483648 до 2147483647
int64 | Знаковые 64-битные целые числа | от -9223372036854775808 до 9223372036854775807

В дополнение к этому существуют два типа-псевдонима: `byte` (то же самое, что `uint8`) и `rune` (то же самое, что `int32`). Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип `byte` в Go часто используется для определения других типов.

Также существует 3 машинно-зависимых целочисленных типа: `uint`, `int` и `uintptr`. Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера:
- `int`: представляет целое число со знаком, которое в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо `int32`, либо `int64`.
- `uint`: представляет целое число только без знака, которое, аналогично типу `int`, в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо `uint32`, либо `uint64`.

Обычно для работы с целыми чсилами используют тип `int`.

#### Числа с плавающей точкой

Числа с плавающей точкой — это числа, которые содержат вещественную часть (вещественные числа) (1.234, 123.4, 0.00001234). 

- Числа с плавающей точкой неточны. Бывают случаи, когда число вообще нельзя представить. Например, результатом вычисления `1.01 - 0.99` будет `0.020000000000000018` - число очень близкое к ожидаемому, но не то же самое.
- Как и целые числа, числа с плавающей точкой имеют определенный размер (32 бита или 64 бита). Использование большего размера увеличивает точность (сколько цифр мы можем использовать для вычисления)
- В дополнение к числам существуют несколько других значений, таких как:  (`NaN`, для вещей наподобие `0/0`), а также положительная и отрицательная бесконечность (`+∞` и `−∞`).

В Go есть два вещественных типа: `float32` и `float64` (соответственно часто называемые вещественными числами с одинарной и двойной точностью), а также два дополнительных типа для представления комплексных чисел (чисел с мнимой частью): `complex64` и `complex128`. При работе с вещественными числами достаточно использовать `float32`, однако, если нужно работать с более точными числами, можно использовать и `float64`.

#### Строки

Строка - это последовательность символов определенной длины, используемая для представления текста. Строки в Go состоят из независимых байтов (в UTF-8), обычно по одному на каждый символ (символы из других языков, таких как китайский, представляются несколькими байтами).

Строковые литералы могут быть созданы с помощью двойных кавычек **"Hello World"** или с помощью обратных апострофов **\`Hello World\`**. Различие между ними в том, что строки в двойных кавычках не могут содержать новые строки (или по другому - несколько строк) и они позволяют использовать особые управляющие последовательности символов. Например, `\n` будет заменена символом новой строки, а `\t` - символом табуляции. 
```go
package main

import "fmt"

func main() {
  fmt.Println(`первая строка
вторая строка
даешь и третью строку!`)
}

// вывод:
//первая строка
//вторая строка
//даешь и третью строку!

//По сути это аналог тройной одинарной кавычки из Python:
// python

print('''первая строка
вторая строка
третья строка
''')
```

Распространенные операции над строками включают в себя нахождение количества байт строки `len("Hello World")`, доступ к отдельному символу в строке `"Hello World"[1]` (строки “индексируются” начиная с 0), и конкатенацию двух строк `"Hello " + "World"`.

**Так как строки в Go хранятся в виде байтов нужно понимать что такой код не выведет символ:**
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello Go"[0]) // вывод: 72
}
```
Представим байты в виде строки:
```go
package main

import "fmt"

func main() {
    fmt.Println(string("Hello Go"[0])) // вывод: H
}
```

#### Логические типы

Булевый тип `bool` - это специальный целочисленный тип, используемый для представления истинности и ложности. Переменная такого типа будет занимать только один байт. С этим типом используются три логических оператора:

Литерал	| Пояснение
-- | --
&& | И
\|\| | ИЛИ
! | НЕ
 
Переменная типа `bool` может принимать только два значения: **truе** или **false**.

### 1.4 Переменные и арифметические операции, ввод/вывод данных

#### Переменные

Для хранения данных в программе применяются переменные. Переменная представляет именованный участок в памяти, который может хранить некоторое значение. Для определения переменной применяется ключевое слово `var`, после которого идет имя переменной, а затем указывается ее тип:
```go
var имя_переменной тип_данных
```

Имя переменной представляет произвольный идентификатор, который состоит из алфавитных и цифровых символов и символа подчеркивания. При этом первым символом должен быть либо алфавитный символ, либо символ подчеркивания. При этом имена не должны представлять одно из ключевых слов: `break`, `case`, `chan`, `const`, `continue`, `default`, `defer`, `else`, `fallthrough`, `for`, `func`, `go`, `goto`, `if`, `import`, `interface`, `map`, `package`, `range`, `return`, `select`, `struct`, `switch`, `type`, `var`.

Пример определения переменной `hello` типа `string`:
```go
var hello string
```

Можно одновременно объявить сразу несколько переменных через запятую:
```go
var a, b, c string
```

Go - **регистрозависимый** язык, то есть переменные с именами `hello` и `Hello` будут представлять собой разные переменные.

Одновременно с объявлением переменной можно задать ей некоторое значение:
```go
var x int = 10
var c string = "Hello World!"
var z float64 = 1.045
```

Также допустимо присваивать значение переменной в момент ее объявления без указания типа данных. В этом случае компилятор сможет сам определить тип присваиваемого значения:
```go
var a = 12
var hello = "Hello"
``` 

Для хранения символов можно использовать `int32`/`rune`. Здесь используются одинарные кавычки. Компилятор определяет код буквы в unicode и присваивает его переменной `symbol`. То есть мы не храним `'c'`, а храним лишь число `99`. Функция `string()` из переданного в него числа `99` делает строку `'c'`.
```go
var symbol int32 = 'c'
fmt.Println(string(symbol))
```

Также существует более краткий способ объявить переменную. Такое объявление доступно только внутри функций:
```go
a := 5

// Это то же самое, что:

var a int = 5

// Также можно объявить вот так:

var a = 5
```

Переменные можно группировать:
```go
package main


import "fmt"
 
func main() {
    var (
        name string = "Dima"
        age int = 23
    )
     
    fmt.Println(name)
    fmt.Println(age)
}
 

// Вывод программы:

Dima

23
```

**Значения по умолчанию**

Когда объявляется переменная, она автоматически содержит значение по умолчанию для своего типа: `0` для `int`, `0.0` для `float`, `false` для `bool`, пустая строка для `string`, `nil` для указателя и т.д.

#### Арифметические операции

У переменных есть разные операции, как в алгебре.
- **+ сложение**
- **- вычитание**
- **\* умножение**
- **/ деление**
- **% остаток от деления** 

Примеры:
```go
a := 100 
b := 10

c := a + b // с = 110
c = a * b  // с = 1000
c = a - b // с = 90
c = a / b  // с = 10
```

При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:
```go
var a int = 10 / 6
------------------
Вывод: 1
```

Чтобы получить в результате деления вещественное число,  как минимум один из операндов также должен представлять собой вещественное число и результат мы должны при этом тоже сохранять в переменную вещественного типа:
```go
var m float32 = 10.0 / 6
----------------------
Вывод: 1.6666666
``` 

**%** Возвращает остаток от деления (в этой операции могут принимать участие **только целые числа**):
```go
var c int = 10 % 3
---------------
Вывод: 1
``` 

Постфиксный инкремент (**x++**). Увеличивает значение переменной на единицу:
```go
var a int = 1
a++
fmt.Println(a)
---------------
Вывод: 2
``` 

Постфиксный декремент (**x--**). Уменьшает значение переменной на единицу:
```go
var a int = 10
a--
fmt.Println(a)
---------------
Вывод: 9
```

#### Чтение данных с консоли

Для чтения данных с консоли нужно воспользоваться методом **fmt.Scan(&a)**, где **&a** - ссылка (адрес) на переменную `a`. Введённое число запишется из консоли в эту переменную и там будет храниться, пока не понадобится её куда-нибудь пристроить/поменять.
```go
package main

import "fmt"
 
func main() {
    var name string
    var age int
    fmt.Print("Введите имя: ")
    fmt.Scan(&name) 
    fmt.Print("Введите возраст: ")
    fmt.Scan(&age)
     
    fmt.Println(name, age)
}
```

Программа сначала прочтёт имя, а затем запишет его в переменную `name`. Аналогично, введённый возраст запишется в переменную `age`. В конце программа выведет эти переменные через пробел.

Также можно читать с консоли сразу несколько переменных:
```go
fmt.Scan(&a, &b, &c)
```

#### Вывод данных на консоль

Для вывода данных на консоль можно использовать два метода, которые присутствуют в пакете `fmt`. Это **Print()** и **Println()**.

Первый метод при выводе нескольких объектов вставляет между ними пробелы, если среди них нет строк.

Второй всегда ставит пробелы между выводимыми объектами, плюс добавляет новую строку. То есть он пригодится, если нам необходимо будет сделать вывод на нескольких строках.
```go
fmt.Print("hello, world")
fmt.Print("hello, world")
// вывод будет в одну строку:
// hello, worldhello, world

// но если мы сделаем вот так:

fmt.Println("hello, world")
fmt.Print("hello, world")
// вывод будет в две строки:
// hello, world
// hello, world

Как выводятся несколько объектов:
```go
fmt.Print("Ivan", 27) // Ivan27

fmt.Println("Ivan", 27) // Ivan 27

fmt.Print(33, 27) // 33 27
```

В первом случае один из объектов строка, поэтому пробел между объектами не ставится. Во втором случае используется метод `Println()`, поэтому пробел ставится в любом случае. В третьем у нас нет строк - поэтому метод `Print()` вставляет пробел между выводимыми объектами.

Еще пример вывода, используя строки и переменные:
```go
package main

import "fmt"

func main() {
    name := "Ivan"
    age := 27
    fmt.Println("My name is", name, "and I am", age, "years old.")
}

// вывод:
// My name is Ivan and I am 27 years old.
```

### 1.5 Комментарии

Программа может иметь комментарии. Комментарии служат для описания действий, которые производит программа или какие-то ее части. При компиляции комментарии не учитываются и не оказывают никакого влияния на работу приложения. Комментарии бывают однострочными и многострочными.

**Однострочный комментарий** располагается в одну строку после двойного слеша `//`. Все, что идет после этих символов, воспринимается компилятором как комментарий. **Многострочный комментарий** заключается между символами `/*` и `*/` и может занимать несколько строк:
```go
/*
    Первая программа 
    на языке Go
*/

package main    // определение пакета для текущего файла

import "fmt"    // подключение пакета fmt

// определение функции main

func main() {
     fmt.Println("Hello Go!")    // вывод строки на консоль   
}
```

### 1.6 Константы

Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Для определения констант применяется ключевое слово `const`:
```go
const pi float64 = 3.1415
```

Мы **не** можем менять значение константы:
```go
const pi float64 = 3.1415
pi = 2.7182             // ! Ошибка
```

Константы, как и обычные переменные, можно объявлять в блоке:
```go
const (
	a int = 45
	b float32 = 3.3
)
```

Также можно не указывать значение следующей константы по порядку (значение будет скопировано):
```go
package main

import (
	"fmt"
)

const(
	A int = 45
	B
	C float32 = 3.3
	D
)
func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}
```

#### iota

**iota** идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.

Предположим, что нам нужно использовать дни недели с их номерами:
```go
const (
	Sunday    = 0
	Monday    = 1
	Tuesday   = 2
	Wednesday = 3
	Thursday  = 4
	Friday    = 5
	Saturday  = 6
)
fmt.Println(Sunday)    // вывод 0
fmt.Println(Saturday)  // вывод 6
```

Сделаем дни недели с использованием **iota**:  
```go
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

func main() {
	fmt.Println(Sunday)   // вывод 0
	fmt.Println(Saturday) // вывод 6
}
``` 

В объявлении константы _предварительно объявленный идентификатор_ **iota** представляет последовательные не типизированные целочисленные константы. Его значение является индексом соответствующего ConstSpec в объявлении константы, начиная с **нуля**. Поскольку он может использоваться в выражениях, он обеспечивает общность, выходящую за рамки простых перечислений. Его можно использовать для построения набора связанных констант:
```go
const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2


const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8



const (
	u         = iota * 42 // u == 0 (индекс  0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс  1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс  2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0
```

### 1.7 Условные выражения

Условные выражения представляют операции отношения и логические операции. Они представляют некоторое условие и возвращают значение типа `bool`: `true` (если условие истинно) или `false` (если условие ложно).

#### Операции отношения

Операции отношения позволяют сравнить два значения.

- `==`. Операция "равно". Возвращает true, если оба операнда равны, и false, если они не равны:
```go
package main
import "fmt"
 
func main() {
    var a int = 8
    var b int = 3
    var c bool = a == b
    fmt.Println(c)      // false
}
``` 

- `>`. Операция "больше чем". Возвращает true, если первый операнд больше второго, и false, если первый операнд меньше второго или операнды равны:
```go
var a int = 8
var b int = 3
var c bool = a > b   // true
``` 

- `<`. Операция "меньше чем". Возвращает true, если первый операнд меньше второго, и false, если первый операнд больше второго или операнды равны:
```go
var a int = 8
var b int = 3
var c bool = a < b   // false
```

- `<=`. Операция "меньше или равно". Возвращает true, если первый операнд меньше или равен второму, и false, если первый операнд больше второго:
```go
var a int = 8
var b int = 3
var c bool = a <= b  // false
``` 

- `>=`. Операция "больше или равно". Возвращает true, если первый операнд больше или равен второму, и false, если первый операнд меньше второго:
```go
var a int = 8
var b int = 3
var c bool = a >= b  // true
```

- `!=`. Операция "не равно". Возвращает true, если первый операнд не равен второму, и false, если оба операнда равны:
```go
var a int = 8
var b int = 3
var c bool = a != b // true
var d bool = a != 8 // false
```

#### Логические операции

Логические операции сравнивают два условия. Как правило, они применяются к отношениям и объединяют несколько операций отношения. К логическим операциям относят следующие:

- `!` (операция отрицания, логическое НЕ). Инвертирует значение. Если операнд равен true, то возвращает false, иначе возвращает true.
```go
var a bool = true
var b bool = !a     // false
var c bool = !b     // true
```

- `&&` (конъюнкция, логическое умножение,  логическое И). Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.
```go
var b bool = 4 > 5 && 6 > 8   // false
var c bool = 3 <= 5 && 10 > 8 // true
```

- `||` (дизъюнкция, логическое сложение, логическое ИЛИ). Возвращает true, если хотя бы один операнд не равен false. Возвращает false, если оба операнда равны false.
```go
var b bool = 4 > 5 || 6 > 8      // false
var c bool = 3 == 5 || 10 > 8    // true
```
