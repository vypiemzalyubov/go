// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/route256/wallet/internal/pkg/storage.Storage -o storage_minimock.go -n MinimockStorage -p mocks

import (
	"context"
	"database/sql"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
)

// MinimockStorage implements mm_storage.Storage
type MinimockStorage struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddAccount          func(ctx context.Context, account *domain.Account) (err error)
	funcAddAccountOrigin    string
	inspectFuncAddAccount   func(ctx context.Context, account *domain.Account)
	afterAddAccountCounter  uint64
	beforeAddAccountCounter uint64
	AddAccountMock          mMinimockStorageAddAccount

	funcCollectOperation          func(ctx context.Context) (i1 int64, err error)
	funcCollectOperationOrigin    string
	inspectFuncCollectOperation   func(ctx context.Context)
	afterCollectOperationCounter  uint64
	beforeCollectOperationCounter uint64
	CollectOperationMock          mMinimockStorageCollectOperation

	funcCreateUser          func(ctx context.Context, user *domain.User) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user *domain.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mMinimockStorageCreateUser

	funcCredit          func(ctx context.Context, accountID string, amount int32, operationID string) (err error)
	funcCreditOrigin    string
	inspectFuncCredit   func(ctx context.Context, accountID string, amount int32, operationID string)
	afterCreditCounter  uint64
	beforeCreditCounter uint64
	CreditMock          mMinimockStorageCredit

	funcDebit          func(ctx context.Context, accountID string, amount int32, operationID string) (err error)
	funcDebitOrigin    string
	inspectFuncDebit   func(ctx context.Context, accountID string, amount int32, operationID string)
	afterDebitCounter  uint64
	beforeDebitCounter uint64
	DebitMock          mMinimockStorageDebit

	funcExec          func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)
	funcExecOrigin    string
	inspectFuncExec   func(ctx context.Context, query string, args ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mMinimockStorageExec

	funcGetAccount          func(ctx context.Context, accountID string) (ap1 *domain.Account, err error)
	funcGetAccountOrigin    string
	inspectFuncGetAccount   func(ctx context.Context, accountID string)
	afterGetAccountCounter  uint64
	beforeGetAccountCounter uint64
	GetAccountMock          mMinimockStorageGetAccount

	funcGetAccountOperations          func(ctx context.Context, accountID string, limit uint64) (aa1 []domain.AccountOperation, err error)
	funcGetAccountOperationsOrigin    string
	inspectFuncGetAccountOperations   func(ctx context.Context, accountID string, limit uint64)
	afterGetAccountOperationsCounter  uint64
	beforeGetAccountOperationsCounter uint64
	GetAccountOperationsMock          mMinimockStorageGetAccountOperations

	funcGetUser          func(ctx context.Context, userID string) (up1 *domain.UserWithAccounts, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, userID string)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mMinimockStorageGetUser

	funcGetUserByPhone          func(ctx context.Context, phone string) (up1 *domain.User, err error)
	funcGetUserByPhoneOrigin    string
	inspectFuncGetUserByPhone   func(ctx context.Context, phone string)
	afterGetUserByPhoneCounter  uint64
	beforeGetUserByPhoneCounter uint64
	GetUserByPhoneMock          mMinimockStorageGetUserByPhone

	funcGetUserSessions          func(ctx context.Context, userID string) (sa1 []string, err error)
	funcGetUserSessionsOrigin    string
	inspectFuncGetUserSessions   func(ctx context.Context, userID string)
	afterGetUserSessionsCounter  uint64
	beforeGetUserSessionsCounter uint64
	GetUserSessionsMock          mMinimockStorageGetUserSessions

	funcLogIn          func(ctx context.Context, userID string, token string) (err error)
	funcLogInOrigin    string
	inspectFuncLogIn   func(ctx context.Context, userID string, token string)
	afterLogInCounter  uint64
	beforeLogInCounter uint64
	LogInMock          mMinimockStorageLogIn

	funcUpgradeUser          func(ctx context.Context, userID string, level string) (err error)
	funcUpgradeUserOrigin    string
	inspectFuncUpgradeUser   func(ctx context.Context, userID string, level string)
	afterUpgradeUserCounter  uint64
	beforeUpgradeUserCounter uint64
	UpgradeUserMock          mMinimockStorageUpgradeUser
}

// NewMinimockStorage returns a mock for mm_storage.Storage
func NewMinimockStorage(t minimock.Tester) *MinimockStorage {
	m := &MinimockStorage{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddAccountMock = mMinimockStorageAddAccount{mock: m}
	m.AddAccountMock.callArgs = []*MinimockStorageAddAccountParams{}

	m.CollectOperationMock = mMinimockStorageCollectOperation{mock: m}
	m.CollectOperationMock.callArgs = []*MinimockStorageCollectOperationParams{}

	m.CreateUserMock = mMinimockStorageCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*MinimockStorageCreateUserParams{}

	m.CreditMock = mMinimockStorageCredit{mock: m}
	m.CreditMock.callArgs = []*MinimockStorageCreditParams{}

	m.DebitMock = mMinimockStorageDebit{mock: m}
	m.DebitMock.callArgs = []*MinimockStorageDebitParams{}

	m.ExecMock = mMinimockStorageExec{mock: m}
	m.ExecMock.callArgs = []*MinimockStorageExecParams{}

	m.GetAccountMock = mMinimockStorageGetAccount{mock: m}
	m.GetAccountMock.callArgs = []*MinimockStorageGetAccountParams{}

	m.GetAccountOperationsMock = mMinimockStorageGetAccountOperations{mock: m}
	m.GetAccountOperationsMock.callArgs = []*MinimockStorageGetAccountOperationsParams{}

	m.GetUserMock = mMinimockStorageGetUser{mock: m}
	m.GetUserMock.callArgs = []*MinimockStorageGetUserParams{}

	m.GetUserByPhoneMock = mMinimockStorageGetUserByPhone{mock: m}
	m.GetUserByPhoneMock.callArgs = []*MinimockStorageGetUserByPhoneParams{}

	m.GetUserSessionsMock = mMinimockStorageGetUserSessions{mock: m}
	m.GetUserSessionsMock.callArgs = []*MinimockStorageGetUserSessionsParams{}

	m.LogInMock = mMinimockStorageLogIn{mock: m}
	m.LogInMock.callArgs = []*MinimockStorageLogInParams{}

	m.UpgradeUserMock = mMinimockStorageUpgradeUser{mock: m}
	m.UpgradeUserMock.callArgs = []*MinimockStorageUpgradeUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMinimockStorageAddAccount struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageAddAccountExpectation
	expectations       []*MinimockStorageAddAccountExpectation

	callArgs []*MinimockStorageAddAccountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageAddAccountExpectation specifies expectation struct of the Storage.AddAccount
type MinimockStorageAddAccountExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageAddAccountParams
	paramPtrs          *MinimockStorageAddAccountParamPtrs
	expectationOrigins MinimockStorageAddAccountExpectationOrigins
	results            *MinimockStorageAddAccountResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageAddAccountParams contains parameters of the Storage.AddAccount
type MinimockStorageAddAccountParams struct {
	ctx     context.Context
	account *domain.Account
}

// MinimockStorageAddAccountParamPtrs contains pointers to parameters of the Storage.AddAccount
type MinimockStorageAddAccountParamPtrs struct {
	ctx     *context.Context
	account **domain.Account
}

// MinimockStorageAddAccountResults contains results of the Storage.AddAccount
type MinimockStorageAddAccountResults struct {
	err error
}

// MinimockStorageAddAccountOrigins contains origins of expectations of the Storage.AddAccount
type MinimockStorageAddAccountExpectationOrigins struct {
	origin        string
	originCtx     string
	originAccount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddAccount *mMinimockStorageAddAccount) Optional() *mMinimockStorageAddAccount {
	mmAddAccount.optional = true
	return mmAddAccount
}

// Expect sets up expected params for Storage.AddAccount
func (mmAddAccount *mMinimockStorageAddAccount) Expect(ctx context.Context, account *domain.Account) *mMinimockStorageAddAccount {
	if mmAddAccount.mock.funcAddAccount != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by Set")
	}

	if mmAddAccount.defaultExpectation == nil {
		mmAddAccount.defaultExpectation = &MinimockStorageAddAccountExpectation{}
	}

	if mmAddAccount.defaultExpectation.paramPtrs != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by ExpectParams functions")
	}

	mmAddAccount.defaultExpectation.params = &MinimockStorageAddAccountParams{ctx, account}
	mmAddAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddAccount.expectations {
		if minimock.Equal(e.params, mmAddAccount.defaultExpectation.params) {
			mmAddAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddAccount.defaultExpectation.params)
		}
	}

	return mmAddAccount
}

// ExpectCtxParam1 sets up expected param ctx for Storage.AddAccount
func (mmAddAccount *mMinimockStorageAddAccount) ExpectCtxParam1(ctx context.Context) *mMinimockStorageAddAccount {
	if mmAddAccount.mock.funcAddAccount != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by Set")
	}

	if mmAddAccount.defaultExpectation == nil {
		mmAddAccount.defaultExpectation = &MinimockStorageAddAccountExpectation{}
	}

	if mmAddAccount.defaultExpectation.params != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by Expect")
	}

	if mmAddAccount.defaultExpectation.paramPtrs == nil {
		mmAddAccount.defaultExpectation.paramPtrs = &MinimockStorageAddAccountParamPtrs{}
	}
	mmAddAccount.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddAccount
}

// ExpectAccountParam2 sets up expected param account for Storage.AddAccount
func (mmAddAccount *mMinimockStorageAddAccount) ExpectAccountParam2(account *domain.Account) *mMinimockStorageAddAccount {
	if mmAddAccount.mock.funcAddAccount != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by Set")
	}

	if mmAddAccount.defaultExpectation == nil {
		mmAddAccount.defaultExpectation = &MinimockStorageAddAccountExpectation{}
	}

	if mmAddAccount.defaultExpectation.params != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by Expect")
	}

	if mmAddAccount.defaultExpectation.paramPtrs == nil {
		mmAddAccount.defaultExpectation.paramPtrs = &MinimockStorageAddAccountParamPtrs{}
	}
	mmAddAccount.defaultExpectation.paramPtrs.account = &account
	mmAddAccount.defaultExpectation.expectationOrigins.originAccount = minimock.CallerInfo(1)

	return mmAddAccount
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddAccount
func (mmAddAccount *mMinimockStorageAddAccount) Inspect(f func(ctx context.Context, account *domain.Account)) *mMinimockStorageAddAccount {
	if mmAddAccount.mock.inspectFuncAddAccount != nil {
		mmAddAccount.mock.t.Fatalf("Inspect function is already set for MinimockStorage.AddAccount")
	}

	mmAddAccount.mock.inspectFuncAddAccount = f

	return mmAddAccount
}

// Return sets up results that will be returned by Storage.AddAccount
func (mmAddAccount *mMinimockStorageAddAccount) Return(err error) *MinimockStorage {
	if mmAddAccount.mock.funcAddAccount != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by Set")
	}

	if mmAddAccount.defaultExpectation == nil {
		mmAddAccount.defaultExpectation = &MinimockStorageAddAccountExpectation{mock: mmAddAccount.mock}
	}
	mmAddAccount.defaultExpectation.results = &MinimockStorageAddAccountResults{err}
	mmAddAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddAccount.mock
}

// Set uses given function f to mock the Storage.AddAccount method
func (mmAddAccount *mMinimockStorageAddAccount) Set(f func(ctx context.Context, account *domain.Account) (err error)) *MinimockStorage {
	if mmAddAccount.defaultExpectation != nil {
		mmAddAccount.mock.t.Fatalf("Default expectation is already set for the Storage.AddAccount method")
	}

	if len(mmAddAccount.expectations) > 0 {
		mmAddAccount.mock.t.Fatalf("Some expectations are already set for the Storage.AddAccount method")
	}

	mmAddAccount.mock.funcAddAccount = f
	mmAddAccount.mock.funcAddAccountOrigin = minimock.CallerInfo(1)
	return mmAddAccount.mock
}

// When sets expectation for the Storage.AddAccount which will trigger the result defined by the following
// Then helper
func (mmAddAccount *mMinimockStorageAddAccount) When(ctx context.Context, account *domain.Account) *MinimockStorageAddAccountExpectation {
	if mmAddAccount.mock.funcAddAccount != nil {
		mmAddAccount.mock.t.Fatalf("MinimockStorage.AddAccount mock is already set by Set")
	}

	expectation := &MinimockStorageAddAccountExpectation{
		mock:               mmAddAccount.mock,
		params:             &MinimockStorageAddAccountParams{ctx, account},
		expectationOrigins: MinimockStorageAddAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddAccount.expectations = append(mmAddAccount.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddAccount return parameters for the expectation previously defined by the When method
func (e *MinimockStorageAddAccountExpectation) Then(err error) *MinimockStorage {
	e.results = &MinimockStorageAddAccountResults{err}
	return e.mock
}

// Times sets number of times Storage.AddAccount should be invoked
func (mmAddAccount *mMinimockStorageAddAccount) Times(n uint64) *mMinimockStorageAddAccount {
	if n == 0 {
		mmAddAccount.mock.t.Fatalf("Times of MinimockStorage.AddAccount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddAccount.expectedInvocations, n)
	mmAddAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddAccount
}

func (mmAddAccount *mMinimockStorageAddAccount) invocationsDone() bool {
	if len(mmAddAccount.expectations) == 0 && mmAddAccount.defaultExpectation == nil && mmAddAccount.mock.funcAddAccount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddAccount.mock.afterAddAccountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddAccount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddAccount implements mm_storage.Storage
func (mmAddAccount *MinimockStorage) AddAccount(ctx context.Context, account *domain.Account) (err error) {
	mm_atomic.AddUint64(&mmAddAccount.beforeAddAccountCounter, 1)
	defer mm_atomic.AddUint64(&mmAddAccount.afterAddAccountCounter, 1)

	mmAddAccount.t.Helper()

	if mmAddAccount.inspectFuncAddAccount != nil {
		mmAddAccount.inspectFuncAddAccount(ctx, account)
	}

	mm_params := MinimockStorageAddAccountParams{ctx, account}

	// Record call args
	mmAddAccount.AddAccountMock.mutex.Lock()
	mmAddAccount.AddAccountMock.callArgs = append(mmAddAccount.AddAccountMock.callArgs, &mm_params)
	mmAddAccount.AddAccountMock.mutex.Unlock()

	for _, e := range mmAddAccount.AddAccountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddAccount.AddAccountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddAccount.AddAccountMock.defaultExpectation.Counter, 1)
		mm_want := mmAddAccount.AddAccountMock.defaultExpectation.params
		mm_want_ptrs := mmAddAccount.AddAccountMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageAddAccountParams{ctx, account}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddAccount.t.Errorf("MinimockStorage.AddAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddAccount.AddAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.account != nil && !minimock.Equal(*mm_want_ptrs.account, mm_got.account) {
				mmAddAccount.t.Errorf("MinimockStorage.AddAccount got unexpected parameter account, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddAccount.AddAccountMock.defaultExpectation.expectationOrigins.originAccount, *mm_want_ptrs.account, mm_got.account, minimock.Diff(*mm_want_ptrs.account, mm_got.account))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddAccount.t.Errorf("MinimockStorage.AddAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddAccount.AddAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddAccount.AddAccountMock.defaultExpectation.results
		if mm_results == nil {
			mmAddAccount.t.Fatal("No results are set for the MinimockStorage.AddAccount")
		}
		return (*mm_results).err
	}
	if mmAddAccount.funcAddAccount != nil {
		return mmAddAccount.funcAddAccount(ctx, account)
	}
	mmAddAccount.t.Fatalf("Unexpected call to MinimockStorage.AddAccount. %v %v", ctx, account)
	return
}

// AddAccountAfterCounter returns a count of finished MinimockStorage.AddAccount invocations
func (mmAddAccount *MinimockStorage) AddAccountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAccount.afterAddAccountCounter)
}

// AddAccountBeforeCounter returns a count of MinimockStorage.AddAccount invocations
func (mmAddAccount *MinimockStorage) AddAccountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAccount.beforeAddAccountCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.AddAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddAccount *mMinimockStorageAddAccount) Calls() []*MinimockStorageAddAccountParams {
	mmAddAccount.mutex.RLock()

	argCopy := make([]*MinimockStorageAddAccountParams, len(mmAddAccount.callArgs))
	copy(argCopy, mmAddAccount.callArgs)

	mmAddAccount.mutex.RUnlock()

	return argCopy
}

// MinimockAddAccountDone returns true if the count of the AddAccount invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockAddAccountDone() bool {
	if m.AddAccountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddAccountMock.invocationsDone()
}

// MinimockAddAccountInspect logs each unmet expectation
func (m *MinimockStorage) MinimockAddAccountInspect() {
	for _, e := range m.AddAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.AddAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddAccountCounter := mm_atomic.LoadUint64(&m.afterAddAccountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddAccountMock.defaultExpectation != nil && afterAddAccountCounter < 1 {
		if m.AddAccountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.AddAccount at\n%s", m.AddAccountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.AddAccount at\n%s with params: %#v", m.AddAccountMock.defaultExpectation.expectationOrigins.origin, *m.AddAccountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAccount != nil && afterAddAccountCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.AddAccount at\n%s", m.funcAddAccountOrigin)
	}

	if !m.AddAccountMock.invocationsDone() && afterAddAccountCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.AddAccount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddAccountMock.expectedInvocations), m.AddAccountMock.expectedInvocationsOrigin, afterAddAccountCounter)
	}
}

type mMinimockStorageCollectOperation struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageCollectOperationExpectation
	expectations       []*MinimockStorageCollectOperationExpectation

	callArgs []*MinimockStorageCollectOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageCollectOperationExpectation specifies expectation struct of the Storage.CollectOperation
type MinimockStorageCollectOperationExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageCollectOperationParams
	paramPtrs          *MinimockStorageCollectOperationParamPtrs
	expectationOrigins MinimockStorageCollectOperationExpectationOrigins
	results            *MinimockStorageCollectOperationResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageCollectOperationParams contains parameters of the Storage.CollectOperation
type MinimockStorageCollectOperationParams struct {
	ctx context.Context
}

// MinimockStorageCollectOperationParamPtrs contains pointers to parameters of the Storage.CollectOperation
type MinimockStorageCollectOperationParamPtrs struct {
	ctx *context.Context
}

// MinimockStorageCollectOperationResults contains results of the Storage.CollectOperation
type MinimockStorageCollectOperationResults struct {
	i1  int64
	err error
}

// MinimockStorageCollectOperationOrigins contains origins of expectations of the Storage.CollectOperation
type MinimockStorageCollectOperationExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCollectOperation *mMinimockStorageCollectOperation) Optional() *mMinimockStorageCollectOperation {
	mmCollectOperation.optional = true
	return mmCollectOperation
}

// Expect sets up expected params for Storage.CollectOperation
func (mmCollectOperation *mMinimockStorageCollectOperation) Expect(ctx context.Context) *mMinimockStorageCollectOperation {
	if mmCollectOperation.mock.funcCollectOperation != nil {
		mmCollectOperation.mock.t.Fatalf("MinimockStorage.CollectOperation mock is already set by Set")
	}

	if mmCollectOperation.defaultExpectation == nil {
		mmCollectOperation.defaultExpectation = &MinimockStorageCollectOperationExpectation{}
	}

	if mmCollectOperation.defaultExpectation.paramPtrs != nil {
		mmCollectOperation.mock.t.Fatalf("MinimockStorage.CollectOperation mock is already set by ExpectParams functions")
	}

	mmCollectOperation.defaultExpectation.params = &MinimockStorageCollectOperationParams{ctx}
	mmCollectOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCollectOperation.expectations {
		if minimock.Equal(e.params, mmCollectOperation.defaultExpectation.params) {
			mmCollectOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCollectOperation.defaultExpectation.params)
		}
	}

	return mmCollectOperation
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CollectOperation
func (mmCollectOperation *mMinimockStorageCollectOperation) ExpectCtxParam1(ctx context.Context) *mMinimockStorageCollectOperation {
	if mmCollectOperation.mock.funcCollectOperation != nil {
		mmCollectOperation.mock.t.Fatalf("MinimockStorage.CollectOperation mock is already set by Set")
	}

	if mmCollectOperation.defaultExpectation == nil {
		mmCollectOperation.defaultExpectation = &MinimockStorageCollectOperationExpectation{}
	}

	if mmCollectOperation.defaultExpectation.params != nil {
		mmCollectOperation.mock.t.Fatalf("MinimockStorage.CollectOperation mock is already set by Expect")
	}

	if mmCollectOperation.defaultExpectation.paramPtrs == nil {
		mmCollectOperation.defaultExpectation.paramPtrs = &MinimockStorageCollectOperationParamPtrs{}
	}
	mmCollectOperation.defaultExpectation.paramPtrs.ctx = &ctx
	mmCollectOperation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCollectOperation
}

// Inspect accepts an inspector function that has same arguments as the Storage.CollectOperation
func (mmCollectOperation *mMinimockStorageCollectOperation) Inspect(f func(ctx context.Context)) *mMinimockStorageCollectOperation {
	if mmCollectOperation.mock.inspectFuncCollectOperation != nil {
		mmCollectOperation.mock.t.Fatalf("Inspect function is already set for MinimockStorage.CollectOperation")
	}

	mmCollectOperation.mock.inspectFuncCollectOperation = f

	return mmCollectOperation
}

// Return sets up results that will be returned by Storage.CollectOperation
func (mmCollectOperation *mMinimockStorageCollectOperation) Return(i1 int64, err error) *MinimockStorage {
	if mmCollectOperation.mock.funcCollectOperation != nil {
		mmCollectOperation.mock.t.Fatalf("MinimockStorage.CollectOperation mock is already set by Set")
	}

	if mmCollectOperation.defaultExpectation == nil {
		mmCollectOperation.defaultExpectation = &MinimockStorageCollectOperationExpectation{mock: mmCollectOperation.mock}
	}
	mmCollectOperation.defaultExpectation.results = &MinimockStorageCollectOperationResults{i1, err}
	mmCollectOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCollectOperation.mock
}

// Set uses given function f to mock the Storage.CollectOperation method
func (mmCollectOperation *mMinimockStorageCollectOperation) Set(f func(ctx context.Context) (i1 int64, err error)) *MinimockStorage {
	if mmCollectOperation.defaultExpectation != nil {
		mmCollectOperation.mock.t.Fatalf("Default expectation is already set for the Storage.CollectOperation method")
	}

	if len(mmCollectOperation.expectations) > 0 {
		mmCollectOperation.mock.t.Fatalf("Some expectations are already set for the Storage.CollectOperation method")
	}

	mmCollectOperation.mock.funcCollectOperation = f
	mmCollectOperation.mock.funcCollectOperationOrigin = minimock.CallerInfo(1)
	return mmCollectOperation.mock
}

// When sets expectation for the Storage.CollectOperation which will trigger the result defined by the following
// Then helper
func (mmCollectOperation *mMinimockStorageCollectOperation) When(ctx context.Context) *MinimockStorageCollectOperationExpectation {
	if mmCollectOperation.mock.funcCollectOperation != nil {
		mmCollectOperation.mock.t.Fatalf("MinimockStorage.CollectOperation mock is already set by Set")
	}

	expectation := &MinimockStorageCollectOperationExpectation{
		mock:               mmCollectOperation.mock,
		params:             &MinimockStorageCollectOperationParams{ctx},
		expectationOrigins: MinimockStorageCollectOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCollectOperation.expectations = append(mmCollectOperation.expectations, expectation)
	return expectation
}

// Then sets up Storage.CollectOperation return parameters for the expectation previously defined by the When method
func (e *MinimockStorageCollectOperationExpectation) Then(i1 int64, err error) *MinimockStorage {
	e.results = &MinimockStorageCollectOperationResults{i1, err}
	return e.mock
}

// Times sets number of times Storage.CollectOperation should be invoked
func (mmCollectOperation *mMinimockStorageCollectOperation) Times(n uint64) *mMinimockStorageCollectOperation {
	if n == 0 {
		mmCollectOperation.mock.t.Fatalf("Times of MinimockStorage.CollectOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCollectOperation.expectedInvocations, n)
	mmCollectOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCollectOperation
}

func (mmCollectOperation *mMinimockStorageCollectOperation) invocationsDone() bool {
	if len(mmCollectOperation.expectations) == 0 && mmCollectOperation.defaultExpectation == nil && mmCollectOperation.mock.funcCollectOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCollectOperation.mock.afterCollectOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCollectOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CollectOperation implements mm_storage.Storage
func (mmCollectOperation *MinimockStorage) CollectOperation(ctx context.Context) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCollectOperation.beforeCollectOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmCollectOperation.afterCollectOperationCounter, 1)

	mmCollectOperation.t.Helper()

	if mmCollectOperation.inspectFuncCollectOperation != nil {
		mmCollectOperation.inspectFuncCollectOperation(ctx)
	}

	mm_params := MinimockStorageCollectOperationParams{ctx}

	// Record call args
	mmCollectOperation.CollectOperationMock.mutex.Lock()
	mmCollectOperation.CollectOperationMock.callArgs = append(mmCollectOperation.CollectOperationMock.callArgs, &mm_params)
	mmCollectOperation.CollectOperationMock.mutex.Unlock()

	for _, e := range mmCollectOperation.CollectOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCollectOperation.CollectOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCollectOperation.CollectOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmCollectOperation.CollectOperationMock.defaultExpectation.params
		mm_want_ptrs := mmCollectOperation.CollectOperationMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageCollectOperationParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCollectOperation.t.Errorf("MinimockStorage.CollectOperation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCollectOperation.CollectOperationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCollectOperation.t.Errorf("MinimockStorage.CollectOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCollectOperation.CollectOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCollectOperation.CollectOperationMock.defaultExpectation.results
		if mm_results == nil {
			mmCollectOperation.t.Fatal("No results are set for the MinimockStorage.CollectOperation")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCollectOperation.funcCollectOperation != nil {
		return mmCollectOperation.funcCollectOperation(ctx)
	}
	mmCollectOperation.t.Fatalf("Unexpected call to MinimockStorage.CollectOperation. %v", ctx)
	return
}

// CollectOperationAfterCounter returns a count of finished MinimockStorage.CollectOperation invocations
func (mmCollectOperation *MinimockStorage) CollectOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectOperation.afterCollectOperationCounter)
}

// CollectOperationBeforeCounter returns a count of MinimockStorage.CollectOperation invocations
func (mmCollectOperation *MinimockStorage) CollectOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectOperation.beforeCollectOperationCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.CollectOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCollectOperation *mMinimockStorageCollectOperation) Calls() []*MinimockStorageCollectOperationParams {
	mmCollectOperation.mutex.RLock()

	argCopy := make([]*MinimockStorageCollectOperationParams, len(mmCollectOperation.callArgs))
	copy(argCopy, mmCollectOperation.callArgs)

	mmCollectOperation.mutex.RUnlock()

	return argCopy
}

// MinimockCollectOperationDone returns true if the count of the CollectOperation invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockCollectOperationDone() bool {
	if m.CollectOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CollectOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CollectOperationMock.invocationsDone()
}

// MinimockCollectOperationInspect logs each unmet expectation
func (m *MinimockStorage) MinimockCollectOperationInspect() {
	for _, e := range m.CollectOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.CollectOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCollectOperationCounter := mm_atomic.LoadUint64(&m.afterCollectOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CollectOperationMock.defaultExpectation != nil && afterCollectOperationCounter < 1 {
		if m.CollectOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.CollectOperation at\n%s", m.CollectOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.CollectOperation at\n%s with params: %#v", m.CollectOperationMock.defaultExpectation.expectationOrigins.origin, *m.CollectOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCollectOperation != nil && afterCollectOperationCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.CollectOperation at\n%s", m.funcCollectOperationOrigin)
	}

	if !m.CollectOperationMock.invocationsDone() && afterCollectOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.CollectOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CollectOperationMock.expectedInvocations), m.CollectOperationMock.expectedInvocationsOrigin, afterCollectOperationCounter)
	}
}

type mMinimockStorageCreateUser struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageCreateUserExpectation
	expectations       []*MinimockStorageCreateUserExpectation

	callArgs []*MinimockStorageCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageCreateUserExpectation specifies expectation struct of the Storage.CreateUser
type MinimockStorageCreateUserExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageCreateUserParams
	paramPtrs          *MinimockStorageCreateUserParamPtrs
	expectationOrigins MinimockStorageCreateUserExpectationOrigins
	results            *MinimockStorageCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageCreateUserParams contains parameters of the Storage.CreateUser
type MinimockStorageCreateUserParams struct {
	ctx  context.Context
	user *domain.User
}

// MinimockStorageCreateUserParamPtrs contains pointers to parameters of the Storage.CreateUser
type MinimockStorageCreateUserParamPtrs struct {
	ctx  *context.Context
	user **domain.User
}

// MinimockStorageCreateUserResults contains results of the Storage.CreateUser
type MinimockStorageCreateUserResults struct {
	err error
}

// MinimockStorageCreateUserOrigins contains origins of expectations of the Storage.CreateUser
type MinimockStorageCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mMinimockStorageCreateUser) Optional() *mMinimockStorageCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Storage.CreateUser
func (mmCreateUser *mMinimockStorageCreateUser) Expect(ctx context.Context, user *domain.User) *mMinimockStorageCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &MinimockStorageCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &MinimockStorageCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CreateUser
func (mmCreateUser *mMinimockStorageCreateUser) ExpectCtxParam1(ctx context.Context) *mMinimockStorageCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &MinimockStorageCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &MinimockStorageCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for Storage.CreateUser
func (mmCreateUser *mMinimockStorageCreateUser) ExpectUserParam2(user *domain.User) *mMinimockStorageCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &MinimockStorageCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &MinimockStorageCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Storage.CreateUser
func (mmCreateUser *mMinimockStorageCreateUser) Inspect(f func(ctx context.Context, user *domain.User)) *mMinimockStorageCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for MinimockStorage.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Storage.CreateUser
func (mmCreateUser *mMinimockStorageCreateUser) Return(err error) *MinimockStorage {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &MinimockStorageCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &MinimockStorageCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the Storage.CreateUser method
func (mmCreateUser *mMinimockStorageCreateUser) Set(f func(ctx context.Context, user *domain.User) (err error)) *MinimockStorage {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Storage.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Storage.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the Storage.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mMinimockStorageCreateUser) When(ctx context.Context, user *domain.User) *MinimockStorageCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("MinimockStorage.CreateUser mock is already set by Set")
	}

	expectation := &MinimockStorageCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &MinimockStorageCreateUserParams{ctx, user},
		expectationOrigins: MinimockStorageCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Storage.CreateUser return parameters for the expectation previously defined by the When method
func (e *MinimockStorageCreateUserExpectation) Then(err error) *MinimockStorage {
	e.results = &MinimockStorageCreateUserResults{err}
	return e.mock
}

// Times sets number of times Storage.CreateUser should be invoked
func (mmCreateUser *mMinimockStorageCreateUser) Times(n uint64) *mMinimockStorageCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of MinimockStorage.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mMinimockStorageCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_storage.Storage
func (mmCreateUser *MinimockStorage) CreateUser(ctx context.Context, user *domain.User) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := MinimockStorageCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("MinimockStorage.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("MinimockStorage.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("MinimockStorage.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the MinimockStorage.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to MinimockStorage.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished MinimockStorage.CreateUser invocations
func (mmCreateUser *MinimockStorage) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of MinimockStorage.CreateUser invocations
func (mmCreateUser *MinimockStorage) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mMinimockStorageCreateUser) Calls() []*MinimockStorageCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*MinimockStorageCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *MinimockStorage) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mMinimockStorageCredit struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageCreditExpectation
	expectations       []*MinimockStorageCreditExpectation

	callArgs []*MinimockStorageCreditParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageCreditExpectation specifies expectation struct of the Storage.Credit
type MinimockStorageCreditExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageCreditParams
	paramPtrs          *MinimockStorageCreditParamPtrs
	expectationOrigins MinimockStorageCreditExpectationOrigins
	results            *MinimockStorageCreditResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageCreditParams contains parameters of the Storage.Credit
type MinimockStorageCreditParams struct {
	ctx         context.Context
	accountID   string
	amount      int32
	operationID string
}

// MinimockStorageCreditParamPtrs contains pointers to parameters of the Storage.Credit
type MinimockStorageCreditParamPtrs struct {
	ctx         *context.Context
	accountID   *string
	amount      *int32
	operationID *string
}

// MinimockStorageCreditResults contains results of the Storage.Credit
type MinimockStorageCreditResults struct {
	err error
}

// MinimockStorageCreditOrigins contains origins of expectations of the Storage.Credit
type MinimockStorageCreditExpectationOrigins struct {
	origin            string
	originCtx         string
	originAccountID   string
	originAmount      string
	originOperationID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCredit *mMinimockStorageCredit) Optional() *mMinimockStorageCredit {
	mmCredit.optional = true
	return mmCredit
}

// Expect sets up expected params for Storage.Credit
func (mmCredit *mMinimockStorageCredit) Expect(ctx context.Context, accountID string, amount int32, operationID string) *mMinimockStorageCredit {
	if mmCredit.mock.funcCredit != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Set")
	}

	if mmCredit.defaultExpectation == nil {
		mmCredit.defaultExpectation = &MinimockStorageCreditExpectation{}
	}

	if mmCredit.defaultExpectation.paramPtrs != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by ExpectParams functions")
	}

	mmCredit.defaultExpectation.params = &MinimockStorageCreditParams{ctx, accountID, amount, operationID}
	mmCredit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCredit.expectations {
		if minimock.Equal(e.params, mmCredit.defaultExpectation.params) {
			mmCredit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCredit.defaultExpectation.params)
		}
	}

	return mmCredit
}

// ExpectCtxParam1 sets up expected param ctx for Storage.Credit
func (mmCredit *mMinimockStorageCredit) ExpectCtxParam1(ctx context.Context) *mMinimockStorageCredit {
	if mmCredit.mock.funcCredit != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Set")
	}

	if mmCredit.defaultExpectation == nil {
		mmCredit.defaultExpectation = &MinimockStorageCreditExpectation{}
	}

	if mmCredit.defaultExpectation.params != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Expect")
	}

	if mmCredit.defaultExpectation.paramPtrs == nil {
		mmCredit.defaultExpectation.paramPtrs = &MinimockStorageCreditParamPtrs{}
	}
	mmCredit.defaultExpectation.paramPtrs.ctx = &ctx
	mmCredit.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCredit
}

// ExpectAccountIDParam2 sets up expected param accountID for Storage.Credit
func (mmCredit *mMinimockStorageCredit) ExpectAccountIDParam2(accountID string) *mMinimockStorageCredit {
	if mmCredit.mock.funcCredit != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Set")
	}

	if mmCredit.defaultExpectation == nil {
		mmCredit.defaultExpectation = &MinimockStorageCreditExpectation{}
	}

	if mmCredit.defaultExpectation.params != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Expect")
	}

	if mmCredit.defaultExpectation.paramPtrs == nil {
		mmCredit.defaultExpectation.paramPtrs = &MinimockStorageCreditParamPtrs{}
	}
	mmCredit.defaultExpectation.paramPtrs.accountID = &accountID
	mmCredit.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

	return mmCredit
}

// ExpectAmountParam3 sets up expected param amount for Storage.Credit
func (mmCredit *mMinimockStorageCredit) ExpectAmountParam3(amount int32) *mMinimockStorageCredit {
	if mmCredit.mock.funcCredit != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Set")
	}

	if mmCredit.defaultExpectation == nil {
		mmCredit.defaultExpectation = &MinimockStorageCreditExpectation{}
	}

	if mmCredit.defaultExpectation.params != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Expect")
	}

	if mmCredit.defaultExpectation.paramPtrs == nil {
		mmCredit.defaultExpectation.paramPtrs = &MinimockStorageCreditParamPtrs{}
	}
	mmCredit.defaultExpectation.paramPtrs.amount = &amount
	mmCredit.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmCredit
}

// ExpectOperationIDParam4 sets up expected param operationID for Storage.Credit
func (mmCredit *mMinimockStorageCredit) ExpectOperationIDParam4(operationID string) *mMinimockStorageCredit {
	if mmCredit.mock.funcCredit != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Set")
	}

	if mmCredit.defaultExpectation == nil {
		mmCredit.defaultExpectation = &MinimockStorageCreditExpectation{}
	}

	if mmCredit.defaultExpectation.params != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Expect")
	}

	if mmCredit.defaultExpectation.paramPtrs == nil {
		mmCredit.defaultExpectation.paramPtrs = &MinimockStorageCreditParamPtrs{}
	}
	mmCredit.defaultExpectation.paramPtrs.operationID = &operationID
	mmCredit.defaultExpectation.expectationOrigins.originOperationID = minimock.CallerInfo(1)

	return mmCredit
}

// Inspect accepts an inspector function that has same arguments as the Storage.Credit
func (mmCredit *mMinimockStorageCredit) Inspect(f func(ctx context.Context, accountID string, amount int32, operationID string)) *mMinimockStorageCredit {
	if mmCredit.mock.inspectFuncCredit != nil {
		mmCredit.mock.t.Fatalf("Inspect function is already set for MinimockStorage.Credit")
	}

	mmCredit.mock.inspectFuncCredit = f

	return mmCredit
}

// Return sets up results that will be returned by Storage.Credit
func (mmCredit *mMinimockStorageCredit) Return(err error) *MinimockStorage {
	if mmCredit.mock.funcCredit != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Set")
	}

	if mmCredit.defaultExpectation == nil {
		mmCredit.defaultExpectation = &MinimockStorageCreditExpectation{mock: mmCredit.mock}
	}
	mmCredit.defaultExpectation.results = &MinimockStorageCreditResults{err}
	mmCredit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCredit.mock
}

// Set uses given function f to mock the Storage.Credit method
func (mmCredit *mMinimockStorageCredit) Set(f func(ctx context.Context, accountID string, amount int32, operationID string) (err error)) *MinimockStorage {
	if mmCredit.defaultExpectation != nil {
		mmCredit.mock.t.Fatalf("Default expectation is already set for the Storage.Credit method")
	}

	if len(mmCredit.expectations) > 0 {
		mmCredit.mock.t.Fatalf("Some expectations are already set for the Storage.Credit method")
	}

	mmCredit.mock.funcCredit = f
	mmCredit.mock.funcCreditOrigin = minimock.CallerInfo(1)
	return mmCredit.mock
}

// When sets expectation for the Storage.Credit which will trigger the result defined by the following
// Then helper
func (mmCredit *mMinimockStorageCredit) When(ctx context.Context, accountID string, amount int32, operationID string) *MinimockStorageCreditExpectation {
	if mmCredit.mock.funcCredit != nil {
		mmCredit.mock.t.Fatalf("MinimockStorage.Credit mock is already set by Set")
	}

	expectation := &MinimockStorageCreditExpectation{
		mock:               mmCredit.mock,
		params:             &MinimockStorageCreditParams{ctx, accountID, amount, operationID},
		expectationOrigins: MinimockStorageCreditExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCredit.expectations = append(mmCredit.expectations, expectation)
	return expectation
}

// Then sets up Storage.Credit return parameters for the expectation previously defined by the When method
func (e *MinimockStorageCreditExpectation) Then(err error) *MinimockStorage {
	e.results = &MinimockStorageCreditResults{err}
	return e.mock
}

// Times sets number of times Storage.Credit should be invoked
func (mmCredit *mMinimockStorageCredit) Times(n uint64) *mMinimockStorageCredit {
	if n == 0 {
		mmCredit.mock.t.Fatalf("Times of MinimockStorage.Credit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCredit.expectedInvocations, n)
	mmCredit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCredit
}

func (mmCredit *mMinimockStorageCredit) invocationsDone() bool {
	if len(mmCredit.expectations) == 0 && mmCredit.defaultExpectation == nil && mmCredit.mock.funcCredit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCredit.mock.afterCreditCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCredit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Credit implements mm_storage.Storage
func (mmCredit *MinimockStorage) Credit(ctx context.Context, accountID string, amount int32, operationID string) (err error) {
	mm_atomic.AddUint64(&mmCredit.beforeCreditCounter, 1)
	defer mm_atomic.AddUint64(&mmCredit.afterCreditCounter, 1)

	mmCredit.t.Helper()

	if mmCredit.inspectFuncCredit != nil {
		mmCredit.inspectFuncCredit(ctx, accountID, amount, operationID)
	}

	mm_params := MinimockStorageCreditParams{ctx, accountID, amount, operationID}

	// Record call args
	mmCredit.CreditMock.mutex.Lock()
	mmCredit.CreditMock.callArgs = append(mmCredit.CreditMock.callArgs, &mm_params)
	mmCredit.CreditMock.mutex.Unlock()

	for _, e := range mmCredit.CreditMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCredit.CreditMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCredit.CreditMock.defaultExpectation.Counter, 1)
		mm_want := mmCredit.CreditMock.defaultExpectation.params
		mm_want_ptrs := mmCredit.CreditMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageCreditParams{ctx, accountID, amount, operationID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCredit.t.Errorf("MinimockStorage.Credit got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCredit.CreditMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.accountID != nil && !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) {
				mmCredit.t.Errorf("MinimockStorage.Credit got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCredit.CreditMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmCredit.t.Errorf("MinimockStorage.Credit got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCredit.CreditMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

			if mm_want_ptrs.operationID != nil && !minimock.Equal(*mm_want_ptrs.operationID, mm_got.operationID) {
				mmCredit.t.Errorf("MinimockStorage.Credit got unexpected parameter operationID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCredit.CreditMock.defaultExpectation.expectationOrigins.originOperationID, *mm_want_ptrs.operationID, mm_got.operationID, minimock.Diff(*mm_want_ptrs.operationID, mm_got.operationID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCredit.t.Errorf("MinimockStorage.Credit got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCredit.CreditMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCredit.CreditMock.defaultExpectation.results
		if mm_results == nil {
			mmCredit.t.Fatal("No results are set for the MinimockStorage.Credit")
		}
		return (*mm_results).err
	}
	if mmCredit.funcCredit != nil {
		return mmCredit.funcCredit(ctx, accountID, amount, operationID)
	}
	mmCredit.t.Fatalf("Unexpected call to MinimockStorage.Credit. %v %v %v %v", ctx, accountID, amount, operationID)
	return
}

// CreditAfterCounter returns a count of finished MinimockStorage.Credit invocations
func (mmCredit *MinimockStorage) CreditAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCredit.afterCreditCounter)
}

// CreditBeforeCounter returns a count of MinimockStorage.Credit invocations
func (mmCredit *MinimockStorage) CreditBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCredit.beforeCreditCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.Credit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCredit *mMinimockStorageCredit) Calls() []*MinimockStorageCreditParams {
	mmCredit.mutex.RLock()

	argCopy := make([]*MinimockStorageCreditParams, len(mmCredit.callArgs))
	copy(argCopy, mmCredit.callArgs)

	mmCredit.mutex.RUnlock()

	return argCopy
}

// MinimockCreditDone returns true if the count of the Credit invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockCreditDone() bool {
	if m.CreditMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreditMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreditMock.invocationsDone()
}

// MinimockCreditInspect logs each unmet expectation
func (m *MinimockStorage) MinimockCreditInspect() {
	for _, e := range m.CreditMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.Credit at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreditCounter := mm_atomic.LoadUint64(&m.afterCreditCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreditMock.defaultExpectation != nil && afterCreditCounter < 1 {
		if m.CreditMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.Credit at\n%s", m.CreditMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.Credit at\n%s with params: %#v", m.CreditMock.defaultExpectation.expectationOrigins.origin, *m.CreditMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCredit != nil && afterCreditCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.Credit at\n%s", m.funcCreditOrigin)
	}

	if !m.CreditMock.invocationsDone() && afterCreditCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.Credit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreditMock.expectedInvocations), m.CreditMock.expectedInvocationsOrigin, afterCreditCounter)
	}
}

type mMinimockStorageDebit struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageDebitExpectation
	expectations       []*MinimockStorageDebitExpectation

	callArgs []*MinimockStorageDebitParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageDebitExpectation specifies expectation struct of the Storage.Debit
type MinimockStorageDebitExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageDebitParams
	paramPtrs          *MinimockStorageDebitParamPtrs
	expectationOrigins MinimockStorageDebitExpectationOrigins
	results            *MinimockStorageDebitResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageDebitParams contains parameters of the Storage.Debit
type MinimockStorageDebitParams struct {
	ctx         context.Context
	accountID   string
	amount      int32
	operationID string
}

// MinimockStorageDebitParamPtrs contains pointers to parameters of the Storage.Debit
type MinimockStorageDebitParamPtrs struct {
	ctx         *context.Context
	accountID   *string
	amount      *int32
	operationID *string
}

// MinimockStorageDebitResults contains results of the Storage.Debit
type MinimockStorageDebitResults struct {
	err error
}

// MinimockStorageDebitOrigins contains origins of expectations of the Storage.Debit
type MinimockStorageDebitExpectationOrigins struct {
	origin            string
	originCtx         string
	originAccountID   string
	originAmount      string
	originOperationID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebit *mMinimockStorageDebit) Optional() *mMinimockStorageDebit {
	mmDebit.optional = true
	return mmDebit
}

// Expect sets up expected params for Storage.Debit
func (mmDebit *mMinimockStorageDebit) Expect(ctx context.Context, accountID string, amount int32, operationID string) *mMinimockStorageDebit {
	if mmDebit.mock.funcDebit != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Set")
	}

	if mmDebit.defaultExpectation == nil {
		mmDebit.defaultExpectation = &MinimockStorageDebitExpectation{}
	}

	if mmDebit.defaultExpectation.paramPtrs != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by ExpectParams functions")
	}

	mmDebit.defaultExpectation.params = &MinimockStorageDebitParams{ctx, accountID, amount, operationID}
	mmDebit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebit.expectations {
		if minimock.Equal(e.params, mmDebit.defaultExpectation.params) {
			mmDebit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebit.defaultExpectation.params)
		}
	}

	return mmDebit
}

// ExpectCtxParam1 sets up expected param ctx for Storage.Debit
func (mmDebit *mMinimockStorageDebit) ExpectCtxParam1(ctx context.Context) *mMinimockStorageDebit {
	if mmDebit.mock.funcDebit != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Set")
	}

	if mmDebit.defaultExpectation == nil {
		mmDebit.defaultExpectation = &MinimockStorageDebitExpectation{}
	}

	if mmDebit.defaultExpectation.params != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Expect")
	}

	if mmDebit.defaultExpectation.paramPtrs == nil {
		mmDebit.defaultExpectation.paramPtrs = &MinimockStorageDebitParamPtrs{}
	}
	mmDebit.defaultExpectation.paramPtrs.ctx = &ctx
	mmDebit.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDebit
}

// ExpectAccountIDParam2 sets up expected param accountID for Storage.Debit
func (mmDebit *mMinimockStorageDebit) ExpectAccountIDParam2(accountID string) *mMinimockStorageDebit {
	if mmDebit.mock.funcDebit != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Set")
	}

	if mmDebit.defaultExpectation == nil {
		mmDebit.defaultExpectation = &MinimockStorageDebitExpectation{}
	}

	if mmDebit.defaultExpectation.params != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Expect")
	}

	if mmDebit.defaultExpectation.paramPtrs == nil {
		mmDebit.defaultExpectation.paramPtrs = &MinimockStorageDebitParamPtrs{}
	}
	mmDebit.defaultExpectation.paramPtrs.accountID = &accountID
	mmDebit.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

	return mmDebit
}

// ExpectAmountParam3 sets up expected param amount for Storage.Debit
func (mmDebit *mMinimockStorageDebit) ExpectAmountParam3(amount int32) *mMinimockStorageDebit {
	if mmDebit.mock.funcDebit != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Set")
	}

	if mmDebit.defaultExpectation == nil {
		mmDebit.defaultExpectation = &MinimockStorageDebitExpectation{}
	}

	if mmDebit.defaultExpectation.params != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Expect")
	}

	if mmDebit.defaultExpectation.paramPtrs == nil {
		mmDebit.defaultExpectation.paramPtrs = &MinimockStorageDebitParamPtrs{}
	}
	mmDebit.defaultExpectation.paramPtrs.amount = &amount
	mmDebit.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmDebit
}

// ExpectOperationIDParam4 sets up expected param operationID for Storage.Debit
func (mmDebit *mMinimockStorageDebit) ExpectOperationIDParam4(operationID string) *mMinimockStorageDebit {
	if mmDebit.mock.funcDebit != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Set")
	}

	if mmDebit.defaultExpectation == nil {
		mmDebit.defaultExpectation = &MinimockStorageDebitExpectation{}
	}

	if mmDebit.defaultExpectation.params != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Expect")
	}

	if mmDebit.defaultExpectation.paramPtrs == nil {
		mmDebit.defaultExpectation.paramPtrs = &MinimockStorageDebitParamPtrs{}
	}
	mmDebit.defaultExpectation.paramPtrs.operationID = &operationID
	mmDebit.defaultExpectation.expectationOrigins.originOperationID = minimock.CallerInfo(1)

	return mmDebit
}

// Inspect accepts an inspector function that has same arguments as the Storage.Debit
func (mmDebit *mMinimockStorageDebit) Inspect(f func(ctx context.Context, accountID string, amount int32, operationID string)) *mMinimockStorageDebit {
	if mmDebit.mock.inspectFuncDebit != nil {
		mmDebit.mock.t.Fatalf("Inspect function is already set for MinimockStorage.Debit")
	}

	mmDebit.mock.inspectFuncDebit = f

	return mmDebit
}

// Return sets up results that will be returned by Storage.Debit
func (mmDebit *mMinimockStorageDebit) Return(err error) *MinimockStorage {
	if mmDebit.mock.funcDebit != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Set")
	}

	if mmDebit.defaultExpectation == nil {
		mmDebit.defaultExpectation = &MinimockStorageDebitExpectation{mock: mmDebit.mock}
	}
	mmDebit.defaultExpectation.results = &MinimockStorageDebitResults{err}
	mmDebit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebit.mock
}

// Set uses given function f to mock the Storage.Debit method
func (mmDebit *mMinimockStorageDebit) Set(f func(ctx context.Context, accountID string, amount int32, operationID string) (err error)) *MinimockStorage {
	if mmDebit.defaultExpectation != nil {
		mmDebit.mock.t.Fatalf("Default expectation is already set for the Storage.Debit method")
	}

	if len(mmDebit.expectations) > 0 {
		mmDebit.mock.t.Fatalf("Some expectations are already set for the Storage.Debit method")
	}

	mmDebit.mock.funcDebit = f
	mmDebit.mock.funcDebitOrigin = minimock.CallerInfo(1)
	return mmDebit.mock
}

// When sets expectation for the Storage.Debit which will trigger the result defined by the following
// Then helper
func (mmDebit *mMinimockStorageDebit) When(ctx context.Context, accountID string, amount int32, operationID string) *MinimockStorageDebitExpectation {
	if mmDebit.mock.funcDebit != nil {
		mmDebit.mock.t.Fatalf("MinimockStorage.Debit mock is already set by Set")
	}

	expectation := &MinimockStorageDebitExpectation{
		mock:               mmDebit.mock,
		params:             &MinimockStorageDebitParams{ctx, accountID, amount, operationID},
		expectationOrigins: MinimockStorageDebitExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebit.expectations = append(mmDebit.expectations, expectation)
	return expectation
}

// Then sets up Storage.Debit return parameters for the expectation previously defined by the When method
func (e *MinimockStorageDebitExpectation) Then(err error) *MinimockStorage {
	e.results = &MinimockStorageDebitResults{err}
	return e.mock
}

// Times sets number of times Storage.Debit should be invoked
func (mmDebit *mMinimockStorageDebit) Times(n uint64) *mMinimockStorageDebit {
	if n == 0 {
		mmDebit.mock.t.Fatalf("Times of MinimockStorage.Debit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebit.expectedInvocations, n)
	mmDebit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebit
}

func (mmDebit *mMinimockStorageDebit) invocationsDone() bool {
	if len(mmDebit.expectations) == 0 && mmDebit.defaultExpectation == nil && mmDebit.mock.funcDebit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebit.mock.afterDebitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debit implements mm_storage.Storage
func (mmDebit *MinimockStorage) Debit(ctx context.Context, accountID string, amount int32, operationID string) (err error) {
	mm_atomic.AddUint64(&mmDebit.beforeDebitCounter, 1)
	defer mm_atomic.AddUint64(&mmDebit.afterDebitCounter, 1)

	mmDebit.t.Helper()

	if mmDebit.inspectFuncDebit != nil {
		mmDebit.inspectFuncDebit(ctx, accountID, amount, operationID)
	}

	mm_params := MinimockStorageDebitParams{ctx, accountID, amount, operationID}

	// Record call args
	mmDebit.DebitMock.mutex.Lock()
	mmDebit.DebitMock.callArgs = append(mmDebit.DebitMock.callArgs, &mm_params)
	mmDebit.DebitMock.mutex.Unlock()

	for _, e := range mmDebit.DebitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDebit.DebitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebit.DebitMock.defaultExpectation.Counter, 1)
		mm_want := mmDebit.DebitMock.defaultExpectation.params
		mm_want_ptrs := mmDebit.DebitMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageDebitParams{ctx, accountID, amount, operationID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDebit.t.Errorf("MinimockStorage.Debit got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebit.DebitMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.accountID != nil && !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) {
				mmDebit.t.Errorf("MinimockStorage.Debit got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebit.DebitMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmDebit.t.Errorf("MinimockStorage.Debit got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebit.DebitMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

			if mm_want_ptrs.operationID != nil && !minimock.Equal(*mm_want_ptrs.operationID, mm_got.operationID) {
				mmDebit.t.Errorf("MinimockStorage.Debit got unexpected parameter operationID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebit.DebitMock.defaultExpectation.expectationOrigins.originOperationID, *mm_want_ptrs.operationID, mm_got.operationID, minimock.Diff(*mm_want_ptrs.operationID, mm_got.operationID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebit.t.Errorf("MinimockStorage.Debit got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebit.DebitMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDebit.DebitMock.defaultExpectation.results
		if mm_results == nil {
			mmDebit.t.Fatal("No results are set for the MinimockStorage.Debit")
		}
		return (*mm_results).err
	}
	if mmDebit.funcDebit != nil {
		return mmDebit.funcDebit(ctx, accountID, amount, operationID)
	}
	mmDebit.t.Fatalf("Unexpected call to MinimockStorage.Debit. %v %v %v %v", ctx, accountID, amount, operationID)
	return
}

// DebitAfterCounter returns a count of finished MinimockStorage.Debit invocations
func (mmDebit *MinimockStorage) DebitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebit.afterDebitCounter)
}

// DebitBeforeCounter returns a count of MinimockStorage.Debit invocations
func (mmDebit *MinimockStorage) DebitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebit.beforeDebitCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.Debit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebit *mMinimockStorageDebit) Calls() []*MinimockStorageDebitParams {
	mmDebit.mutex.RLock()

	argCopy := make([]*MinimockStorageDebitParams, len(mmDebit.callArgs))
	copy(argCopy, mmDebit.callArgs)

	mmDebit.mutex.RUnlock()

	return argCopy
}

// MinimockDebitDone returns true if the count of the Debit invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockDebitDone() bool {
	if m.DebitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebitMock.invocationsDone()
}

// MinimockDebitInspect logs each unmet expectation
func (m *MinimockStorage) MinimockDebitInspect() {
	for _, e := range m.DebitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.Debit at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebitCounter := mm_atomic.LoadUint64(&m.afterDebitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebitMock.defaultExpectation != nil && afterDebitCounter < 1 {
		if m.DebitMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.Debit at\n%s", m.DebitMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.Debit at\n%s with params: %#v", m.DebitMock.defaultExpectation.expectationOrigins.origin, *m.DebitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebit != nil && afterDebitCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.Debit at\n%s", m.funcDebitOrigin)
	}

	if !m.DebitMock.invocationsDone() && afterDebitCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.Debit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebitMock.expectedInvocations), m.DebitMock.expectedInvocationsOrigin, afterDebitCounter)
	}
}

type mMinimockStorageExec struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageExecExpectation
	expectations       []*MinimockStorageExecExpectation

	callArgs []*MinimockStorageExecParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageExecExpectation specifies expectation struct of the Storage.Exec
type MinimockStorageExecExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageExecParams
	paramPtrs          *MinimockStorageExecParamPtrs
	expectationOrigins MinimockStorageExecExpectationOrigins
	results            *MinimockStorageExecResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageExecParams contains parameters of the Storage.Exec
type MinimockStorageExecParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// MinimockStorageExecParamPtrs contains pointers to parameters of the Storage.Exec
type MinimockStorageExecParamPtrs struct {
	ctx   *context.Context
	query *string
	args  *[]interface{}
}

// MinimockStorageExecResults contains results of the Storage.Exec
type MinimockStorageExecResults struct {
	r1  sql.Result
	err error
}

// MinimockStorageExecOrigins contains origins of expectations of the Storage.Exec
type MinimockStorageExecExpectationOrigins struct {
	origin      string
	originCtx   string
	originQuery string
	originArgs  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExec *mMinimockStorageExec) Optional() *mMinimockStorageExec {
	mmExec.optional = true
	return mmExec
}

// Expect sets up expected params for Storage.Exec
func (mmExec *mMinimockStorageExec) Expect(ctx context.Context, query string, args ...interface{}) *mMinimockStorageExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &MinimockStorageExecExpectation{}
	}

	if mmExec.defaultExpectation.paramPtrs != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by ExpectParams functions")
	}

	mmExec.defaultExpectation.params = &MinimockStorageExecParams{ctx, query, args}
	mmExec.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// ExpectCtxParam1 sets up expected param ctx for Storage.Exec
func (mmExec *mMinimockStorageExec) ExpectCtxParam1(ctx context.Context) *mMinimockStorageExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &MinimockStorageExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &MinimockStorageExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.ctx = &ctx
	mmExec.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExec
}

// ExpectQueryParam2 sets up expected param query for Storage.Exec
func (mmExec *mMinimockStorageExec) ExpectQueryParam2(query string) *mMinimockStorageExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &MinimockStorageExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &MinimockStorageExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.query = &query
	mmExec.defaultExpectation.expectationOrigins.originQuery = minimock.CallerInfo(1)

	return mmExec
}

// ExpectArgsParam3 sets up expected param args for Storage.Exec
func (mmExec *mMinimockStorageExec) ExpectArgsParam3(args ...interface{}) *mMinimockStorageExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &MinimockStorageExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &MinimockStorageExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.args = &args
	mmExec.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the Storage.Exec
func (mmExec *mMinimockStorageExec) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mMinimockStorageExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for MinimockStorage.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by Storage.Exec
func (mmExec *mMinimockStorageExec) Return(r1 sql.Result, err error) *MinimockStorage {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &MinimockStorageExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &MinimockStorageExecResults{r1, err}
	mmExec.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// Set uses given function f to mock the Storage.Exec method
func (mmExec *mMinimockStorageExec) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)) *MinimockStorage {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the Storage.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the Storage.Exec method")
	}

	mmExec.mock.funcExec = f
	mmExec.mock.funcExecOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// When sets expectation for the Storage.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mMinimockStorageExec) When(ctx context.Context, query string, args ...interface{}) *MinimockStorageExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("MinimockStorage.Exec mock is already set by Set")
	}

	expectation := &MinimockStorageExecExpectation{
		mock:               mmExec.mock,
		params:             &MinimockStorageExecParams{ctx, query, args},
		expectationOrigins: MinimockStorageExecExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up Storage.Exec return parameters for the expectation previously defined by the When method
func (e *MinimockStorageExecExpectation) Then(r1 sql.Result, err error) *MinimockStorage {
	e.results = &MinimockStorageExecResults{r1, err}
	return e.mock
}

// Times sets number of times Storage.Exec should be invoked
func (mmExec *mMinimockStorageExec) Times(n uint64) *mMinimockStorageExec {
	if n == 0 {
		mmExec.mock.t.Fatalf("Times of MinimockStorage.Exec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExec.expectedInvocations, n)
	mmExec.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExec
}

func (mmExec *mMinimockStorageExec) invocationsDone() bool {
	if len(mmExec.expectations) == 0 && mmExec.defaultExpectation == nil && mmExec.mock.funcExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExec.mock.afterExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exec implements mm_storage.Storage
func (mmExec *MinimockStorage) Exec(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	mmExec.t.Helper()

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, query, args...)
	}

	mm_params := MinimockStorageExecParams{ctx, query, args}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_want_ptrs := mmExec.ExecMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageExecParams{ctx, query, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExec.t.Errorf("MinimockStorage.Exec got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.query != nil && !minimock.Equal(*mm_want_ptrs.query, mm_got.query) {
				mmExec.t.Errorf("MinimockStorage.Exec got unexpected parameter query, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originQuery, *mm_want_ptrs.query, mm_got.query, minimock.Diff(*mm_want_ptrs.query, mm_got.query))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmExec.t.Errorf("MinimockStorage.Exec got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("MinimockStorage.Exec got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExec.ExecMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the MinimockStorage.Exec")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, query, args...)
	}
	mmExec.t.Fatalf("Unexpected call to MinimockStorage.Exec. %v %v %v", ctx, query, args)
	return
}

// ExecAfterCounter returns a count of finished MinimockStorage.Exec invocations
func (mmExec *MinimockStorage) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of MinimockStorage.Exec invocations
func (mmExec *MinimockStorage) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mMinimockStorageExec) Calls() []*MinimockStorageExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*MinimockStorageExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockExecDone() bool {
	if m.ExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecMock.invocationsDone()
}

// MinimockExecInspect logs each unmet expectation
func (m *MinimockStorage) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.Exec at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecCounter := mm_atomic.LoadUint64(&m.afterExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && afterExecCounter < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.Exec at\n%s", m.ExecMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.Exec at\n%s with params: %#v", m.ExecMock.defaultExpectation.expectationOrigins.origin, *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && afterExecCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.Exec at\n%s", m.funcExecOrigin)
	}

	if !m.ExecMock.invocationsDone() && afterExecCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.Exec at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecMock.expectedInvocations), m.ExecMock.expectedInvocationsOrigin, afterExecCounter)
	}
}

type mMinimockStorageGetAccount struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageGetAccountExpectation
	expectations       []*MinimockStorageGetAccountExpectation

	callArgs []*MinimockStorageGetAccountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageGetAccountExpectation specifies expectation struct of the Storage.GetAccount
type MinimockStorageGetAccountExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageGetAccountParams
	paramPtrs          *MinimockStorageGetAccountParamPtrs
	expectationOrigins MinimockStorageGetAccountExpectationOrigins
	results            *MinimockStorageGetAccountResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageGetAccountParams contains parameters of the Storage.GetAccount
type MinimockStorageGetAccountParams struct {
	ctx       context.Context
	accountID string
}

// MinimockStorageGetAccountParamPtrs contains pointers to parameters of the Storage.GetAccount
type MinimockStorageGetAccountParamPtrs struct {
	ctx       *context.Context
	accountID *string
}

// MinimockStorageGetAccountResults contains results of the Storage.GetAccount
type MinimockStorageGetAccountResults struct {
	ap1 *domain.Account
	err error
}

// MinimockStorageGetAccountOrigins contains origins of expectations of the Storage.GetAccount
type MinimockStorageGetAccountExpectationOrigins struct {
	origin          string
	originCtx       string
	originAccountID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccount *mMinimockStorageGetAccount) Optional() *mMinimockStorageGetAccount {
	mmGetAccount.optional = true
	return mmGetAccount
}

// Expect sets up expected params for Storage.GetAccount
func (mmGetAccount *mMinimockStorageGetAccount) Expect(ctx context.Context, accountID string) *mMinimockStorageGetAccount {
	if mmGetAccount.mock.funcGetAccount != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by Set")
	}

	if mmGetAccount.defaultExpectation == nil {
		mmGetAccount.defaultExpectation = &MinimockStorageGetAccountExpectation{}
	}

	if mmGetAccount.defaultExpectation.paramPtrs != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by ExpectParams functions")
	}

	mmGetAccount.defaultExpectation.params = &MinimockStorageGetAccountParams{ctx, accountID}
	mmGetAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAccount.expectations {
		if minimock.Equal(e.params, mmGetAccount.defaultExpectation.params) {
			mmGetAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccount.defaultExpectation.params)
		}
	}

	return mmGetAccount
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetAccount
func (mmGetAccount *mMinimockStorageGetAccount) ExpectCtxParam1(ctx context.Context) *mMinimockStorageGetAccount {
	if mmGetAccount.mock.funcGetAccount != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by Set")
	}

	if mmGetAccount.defaultExpectation == nil {
		mmGetAccount.defaultExpectation = &MinimockStorageGetAccountExpectation{}
	}

	if mmGetAccount.defaultExpectation.params != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by Expect")
	}

	if mmGetAccount.defaultExpectation.paramPtrs == nil {
		mmGetAccount.defaultExpectation.paramPtrs = &MinimockStorageGetAccountParamPtrs{}
	}
	mmGetAccount.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAccount
}

// ExpectAccountIDParam2 sets up expected param accountID for Storage.GetAccount
func (mmGetAccount *mMinimockStorageGetAccount) ExpectAccountIDParam2(accountID string) *mMinimockStorageGetAccount {
	if mmGetAccount.mock.funcGetAccount != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by Set")
	}

	if mmGetAccount.defaultExpectation == nil {
		mmGetAccount.defaultExpectation = &MinimockStorageGetAccountExpectation{}
	}

	if mmGetAccount.defaultExpectation.params != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by Expect")
	}

	if mmGetAccount.defaultExpectation.paramPtrs == nil {
		mmGetAccount.defaultExpectation.paramPtrs = &MinimockStorageGetAccountParamPtrs{}
	}
	mmGetAccount.defaultExpectation.paramPtrs.accountID = &accountID
	mmGetAccount.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

	return mmGetAccount
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetAccount
func (mmGetAccount *mMinimockStorageGetAccount) Inspect(f func(ctx context.Context, accountID string)) *mMinimockStorageGetAccount {
	if mmGetAccount.mock.inspectFuncGetAccount != nil {
		mmGetAccount.mock.t.Fatalf("Inspect function is already set for MinimockStorage.GetAccount")
	}

	mmGetAccount.mock.inspectFuncGetAccount = f

	return mmGetAccount
}

// Return sets up results that will be returned by Storage.GetAccount
func (mmGetAccount *mMinimockStorageGetAccount) Return(ap1 *domain.Account, err error) *MinimockStorage {
	if mmGetAccount.mock.funcGetAccount != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by Set")
	}

	if mmGetAccount.defaultExpectation == nil {
		mmGetAccount.defaultExpectation = &MinimockStorageGetAccountExpectation{mock: mmGetAccount.mock}
	}
	mmGetAccount.defaultExpectation.results = &MinimockStorageGetAccountResults{ap1, err}
	mmGetAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAccount.mock
}

// Set uses given function f to mock the Storage.GetAccount method
func (mmGetAccount *mMinimockStorageGetAccount) Set(f func(ctx context.Context, accountID string) (ap1 *domain.Account, err error)) *MinimockStorage {
	if mmGetAccount.defaultExpectation != nil {
		mmGetAccount.mock.t.Fatalf("Default expectation is already set for the Storage.GetAccount method")
	}

	if len(mmGetAccount.expectations) > 0 {
		mmGetAccount.mock.t.Fatalf("Some expectations are already set for the Storage.GetAccount method")
	}

	mmGetAccount.mock.funcGetAccount = f
	mmGetAccount.mock.funcGetAccountOrigin = minimock.CallerInfo(1)
	return mmGetAccount.mock
}

// When sets expectation for the Storage.GetAccount which will trigger the result defined by the following
// Then helper
func (mmGetAccount *mMinimockStorageGetAccount) When(ctx context.Context, accountID string) *MinimockStorageGetAccountExpectation {
	if mmGetAccount.mock.funcGetAccount != nil {
		mmGetAccount.mock.t.Fatalf("MinimockStorage.GetAccount mock is already set by Set")
	}

	expectation := &MinimockStorageGetAccountExpectation{
		mock:               mmGetAccount.mock,
		params:             &MinimockStorageGetAccountParams{ctx, accountID},
		expectationOrigins: MinimockStorageGetAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAccount.expectations = append(mmGetAccount.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetAccount return parameters for the expectation previously defined by the When method
func (e *MinimockStorageGetAccountExpectation) Then(ap1 *domain.Account, err error) *MinimockStorage {
	e.results = &MinimockStorageGetAccountResults{ap1, err}
	return e.mock
}

// Times sets number of times Storage.GetAccount should be invoked
func (mmGetAccount *mMinimockStorageGetAccount) Times(n uint64) *mMinimockStorageGetAccount {
	if n == 0 {
		mmGetAccount.mock.t.Fatalf("Times of MinimockStorage.GetAccount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccount.expectedInvocations, n)
	mmGetAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAccount
}

func (mmGetAccount *mMinimockStorageGetAccount) invocationsDone() bool {
	if len(mmGetAccount.expectations) == 0 && mmGetAccount.defaultExpectation == nil && mmGetAccount.mock.funcGetAccount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccount.mock.afterGetAccountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccount implements mm_storage.Storage
func (mmGetAccount *MinimockStorage) GetAccount(ctx context.Context, accountID string) (ap1 *domain.Account, err error) {
	mm_atomic.AddUint64(&mmGetAccount.beforeGetAccountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccount.afterGetAccountCounter, 1)

	mmGetAccount.t.Helper()

	if mmGetAccount.inspectFuncGetAccount != nil {
		mmGetAccount.inspectFuncGetAccount(ctx, accountID)
	}

	mm_params := MinimockStorageGetAccountParams{ctx, accountID}

	// Record call args
	mmGetAccount.GetAccountMock.mutex.Lock()
	mmGetAccount.GetAccountMock.callArgs = append(mmGetAccount.GetAccountMock.callArgs, &mm_params)
	mmGetAccount.GetAccountMock.mutex.Unlock()

	for _, e := range mmGetAccount.GetAccountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetAccount.GetAccountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccount.GetAccountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccount.GetAccountMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccount.GetAccountMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageGetAccountParams{ctx, accountID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccount.t.Errorf("MinimockStorage.GetAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccount.GetAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.accountID != nil && !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) {
				mmGetAccount.t.Errorf("MinimockStorage.GetAccount got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccount.GetAccountMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccount.t.Errorf("MinimockStorage.GetAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAccount.GetAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccount.GetAccountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccount.t.Fatal("No results are set for the MinimockStorage.GetAccount")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetAccount.funcGetAccount != nil {
		return mmGetAccount.funcGetAccount(ctx, accountID)
	}
	mmGetAccount.t.Fatalf("Unexpected call to MinimockStorage.GetAccount. %v %v", ctx, accountID)
	return
}

// GetAccountAfterCounter returns a count of finished MinimockStorage.GetAccount invocations
func (mmGetAccount *MinimockStorage) GetAccountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccount.afterGetAccountCounter)
}

// GetAccountBeforeCounter returns a count of MinimockStorage.GetAccount invocations
func (mmGetAccount *MinimockStorage) GetAccountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccount.beforeGetAccountCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.GetAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccount *mMinimockStorageGetAccount) Calls() []*MinimockStorageGetAccountParams {
	mmGetAccount.mutex.RLock()

	argCopy := make([]*MinimockStorageGetAccountParams, len(mmGetAccount.callArgs))
	copy(argCopy, mmGetAccount.callArgs)

	mmGetAccount.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccountDone returns true if the count of the GetAccount invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockGetAccountDone() bool {
	if m.GetAccountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccountMock.invocationsDone()
}

// MinimockGetAccountInspect logs each unmet expectation
func (m *MinimockStorage) MinimockGetAccountInspect() {
	for _, e := range m.GetAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.GetAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAccountCounter := mm_atomic.LoadUint64(&m.afterGetAccountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccountMock.defaultExpectation != nil && afterGetAccountCounter < 1 {
		if m.GetAccountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.GetAccount at\n%s", m.GetAccountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.GetAccount at\n%s with params: %#v", m.GetAccountMock.defaultExpectation.expectationOrigins.origin, *m.GetAccountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccount != nil && afterGetAccountCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.GetAccount at\n%s", m.funcGetAccountOrigin)
	}

	if !m.GetAccountMock.invocationsDone() && afterGetAccountCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.GetAccount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccountMock.expectedInvocations), m.GetAccountMock.expectedInvocationsOrigin, afterGetAccountCounter)
	}
}

type mMinimockStorageGetAccountOperations struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageGetAccountOperationsExpectation
	expectations       []*MinimockStorageGetAccountOperationsExpectation

	callArgs []*MinimockStorageGetAccountOperationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageGetAccountOperationsExpectation specifies expectation struct of the Storage.GetAccountOperations
type MinimockStorageGetAccountOperationsExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageGetAccountOperationsParams
	paramPtrs          *MinimockStorageGetAccountOperationsParamPtrs
	expectationOrigins MinimockStorageGetAccountOperationsExpectationOrigins
	results            *MinimockStorageGetAccountOperationsResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageGetAccountOperationsParams contains parameters of the Storage.GetAccountOperations
type MinimockStorageGetAccountOperationsParams struct {
	ctx       context.Context
	accountID string
	limit     uint64
}

// MinimockStorageGetAccountOperationsParamPtrs contains pointers to parameters of the Storage.GetAccountOperations
type MinimockStorageGetAccountOperationsParamPtrs struct {
	ctx       *context.Context
	accountID *string
	limit     *uint64
}

// MinimockStorageGetAccountOperationsResults contains results of the Storage.GetAccountOperations
type MinimockStorageGetAccountOperationsResults struct {
	aa1 []domain.AccountOperation
	err error
}

// MinimockStorageGetAccountOperationsOrigins contains origins of expectations of the Storage.GetAccountOperations
type MinimockStorageGetAccountOperationsExpectationOrigins struct {
	origin          string
	originCtx       string
	originAccountID string
	originLimit     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) Optional() *mMinimockStorageGetAccountOperations {
	mmGetAccountOperations.optional = true
	return mmGetAccountOperations
}

// Expect sets up expected params for Storage.GetAccountOperations
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) Expect(ctx context.Context, accountID string, limit uint64) *mMinimockStorageGetAccountOperations {
	if mmGetAccountOperations.mock.funcGetAccountOperations != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Set")
	}

	if mmGetAccountOperations.defaultExpectation == nil {
		mmGetAccountOperations.defaultExpectation = &MinimockStorageGetAccountOperationsExpectation{}
	}

	if mmGetAccountOperations.defaultExpectation.paramPtrs != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by ExpectParams functions")
	}

	mmGetAccountOperations.defaultExpectation.params = &MinimockStorageGetAccountOperationsParams{ctx, accountID, limit}
	mmGetAccountOperations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAccountOperations.expectations {
		if minimock.Equal(e.params, mmGetAccountOperations.defaultExpectation.params) {
			mmGetAccountOperations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccountOperations.defaultExpectation.params)
		}
	}

	return mmGetAccountOperations
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetAccountOperations
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) ExpectCtxParam1(ctx context.Context) *mMinimockStorageGetAccountOperations {
	if mmGetAccountOperations.mock.funcGetAccountOperations != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Set")
	}

	if mmGetAccountOperations.defaultExpectation == nil {
		mmGetAccountOperations.defaultExpectation = &MinimockStorageGetAccountOperationsExpectation{}
	}

	if mmGetAccountOperations.defaultExpectation.params != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Expect")
	}

	if mmGetAccountOperations.defaultExpectation.paramPtrs == nil {
		mmGetAccountOperations.defaultExpectation.paramPtrs = &MinimockStorageGetAccountOperationsParamPtrs{}
	}
	mmGetAccountOperations.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAccountOperations.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAccountOperations
}

// ExpectAccountIDParam2 sets up expected param accountID for Storage.GetAccountOperations
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) ExpectAccountIDParam2(accountID string) *mMinimockStorageGetAccountOperations {
	if mmGetAccountOperations.mock.funcGetAccountOperations != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Set")
	}

	if mmGetAccountOperations.defaultExpectation == nil {
		mmGetAccountOperations.defaultExpectation = &MinimockStorageGetAccountOperationsExpectation{}
	}

	if mmGetAccountOperations.defaultExpectation.params != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Expect")
	}

	if mmGetAccountOperations.defaultExpectation.paramPtrs == nil {
		mmGetAccountOperations.defaultExpectation.paramPtrs = &MinimockStorageGetAccountOperationsParamPtrs{}
	}
	mmGetAccountOperations.defaultExpectation.paramPtrs.accountID = &accountID
	mmGetAccountOperations.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

	return mmGetAccountOperations
}

// ExpectLimitParam3 sets up expected param limit for Storage.GetAccountOperations
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) ExpectLimitParam3(limit uint64) *mMinimockStorageGetAccountOperations {
	if mmGetAccountOperations.mock.funcGetAccountOperations != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Set")
	}

	if mmGetAccountOperations.defaultExpectation == nil {
		mmGetAccountOperations.defaultExpectation = &MinimockStorageGetAccountOperationsExpectation{}
	}

	if mmGetAccountOperations.defaultExpectation.params != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Expect")
	}

	if mmGetAccountOperations.defaultExpectation.paramPtrs == nil {
		mmGetAccountOperations.defaultExpectation.paramPtrs = &MinimockStorageGetAccountOperationsParamPtrs{}
	}
	mmGetAccountOperations.defaultExpectation.paramPtrs.limit = &limit
	mmGetAccountOperations.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetAccountOperations
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetAccountOperations
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) Inspect(f func(ctx context.Context, accountID string, limit uint64)) *mMinimockStorageGetAccountOperations {
	if mmGetAccountOperations.mock.inspectFuncGetAccountOperations != nil {
		mmGetAccountOperations.mock.t.Fatalf("Inspect function is already set for MinimockStorage.GetAccountOperations")
	}

	mmGetAccountOperations.mock.inspectFuncGetAccountOperations = f

	return mmGetAccountOperations
}

// Return sets up results that will be returned by Storage.GetAccountOperations
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) Return(aa1 []domain.AccountOperation, err error) *MinimockStorage {
	if mmGetAccountOperations.mock.funcGetAccountOperations != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Set")
	}

	if mmGetAccountOperations.defaultExpectation == nil {
		mmGetAccountOperations.defaultExpectation = &MinimockStorageGetAccountOperationsExpectation{mock: mmGetAccountOperations.mock}
	}
	mmGetAccountOperations.defaultExpectation.results = &MinimockStorageGetAccountOperationsResults{aa1, err}
	mmGetAccountOperations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAccountOperations.mock
}

// Set uses given function f to mock the Storage.GetAccountOperations method
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) Set(f func(ctx context.Context, accountID string, limit uint64) (aa1 []domain.AccountOperation, err error)) *MinimockStorage {
	if mmGetAccountOperations.defaultExpectation != nil {
		mmGetAccountOperations.mock.t.Fatalf("Default expectation is already set for the Storage.GetAccountOperations method")
	}

	if len(mmGetAccountOperations.expectations) > 0 {
		mmGetAccountOperations.mock.t.Fatalf("Some expectations are already set for the Storage.GetAccountOperations method")
	}

	mmGetAccountOperations.mock.funcGetAccountOperations = f
	mmGetAccountOperations.mock.funcGetAccountOperationsOrigin = minimock.CallerInfo(1)
	return mmGetAccountOperations.mock
}

// When sets expectation for the Storage.GetAccountOperations which will trigger the result defined by the following
// Then helper
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) When(ctx context.Context, accountID string, limit uint64) *MinimockStorageGetAccountOperationsExpectation {
	if mmGetAccountOperations.mock.funcGetAccountOperations != nil {
		mmGetAccountOperations.mock.t.Fatalf("MinimockStorage.GetAccountOperations mock is already set by Set")
	}

	expectation := &MinimockStorageGetAccountOperationsExpectation{
		mock:               mmGetAccountOperations.mock,
		params:             &MinimockStorageGetAccountOperationsParams{ctx, accountID, limit},
		expectationOrigins: MinimockStorageGetAccountOperationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAccountOperations.expectations = append(mmGetAccountOperations.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetAccountOperations return parameters for the expectation previously defined by the When method
func (e *MinimockStorageGetAccountOperationsExpectation) Then(aa1 []domain.AccountOperation, err error) *MinimockStorage {
	e.results = &MinimockStorageGetAccountOperationsResults{aa1, err}
	return e.mock
}

// Times sets number of times Storage.GetAccountOperations should be invoked
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) Times(n uint64) *mMinimockStorageGetAccountOperations {
	if n == 0 {
		mmGetAccountOperations.mock.t.Fatalf("Times of MinimockStorage.GetAccountOperations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccountOperations.expectedInvocations, n)
	mmGetAccountOperations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAccountOperations
}

func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) invocationsDone() bool {
	if len(mmGetAccountOperations.expectations) == 0 && mmGetAccountOperations.defaultExpectation == nil && mmGetAccountOperations.mock.funcGetAccountOperations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccountOperations.mock.afterGetAccountOperationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccountOperations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccountOperations implements mm_storage.Storage
func (mmGetAccountOperations *MinimockStorage) GetAccountOperations(ctx context.Context, accountID string, limit uint64) (aa1 []domain.AccountOperation, err error) {
	mm_atomic.AddUint64(&mmGetAccountOperations.beforeGetAccountOperationsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccountOperations.afterGetAccountOperationsCounter, 1)

	mmGetAccountOperations.t.Helper()

	if mmGetAccountOperations.inspectFuncGetAccountOperations != nil {
		mmGetAccountOperations.inspectFuncGetAccountOperations(ctx, accountID, limit)
	}

	mm_params := MinimockStorageGetAccountOperationsParams{ctx, accountID, limit}

	// Record call args
	mmGetAccountOperations.GetAccountOperationsMock.mutex.Lock()
	mmGetAccountOperations.GetAccountOperationsMock.callArgs = append(mmGetAccountOperations.GetAccountOperationsMock.callArgs, &mm_params)
	mmGetAccountOperations.GetAccountOperationsMock.mutex.Unlock()

	for _, e := range mmGetAccountOperations.GetAccountOperationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.aa1, e.results.err
		}
	}

	if mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageGetAccountOperationsParams{ctx, accountID, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccountOperations.t.Errorf("MinimockStorage.GetAccountOperations got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.accountID != nil && !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) {
				mmGetAccountOperations.t.Errorf("MinimockStorage.GetAccountOperations got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetAccountOperations.t.Errorf("MinimockStorage.GetAccountOperations got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccountOperations.t.Errorf("MinimockStorage.GetAccountOperations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccountOperations.GetAccountOperationsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccountOperations.t.Fatal("No results are set for the MinimockStorage.GetAccountOperations")
		}
		return (*mm_results).aa1, (*mm_results).err
	}
	if mmGetAccountOperations.funcGetAccountOperations != nil {
		return mmGetAccountOperations.funcGetAccountOperations(ctx, accountID, limit)
	}
	mmGetAccountOperations.t.Fatalf("Unexpected call to MinimockStorage.GetAccountOperations. %v %v %v", ctx, accountID, limit)
	return
}

// GetAccountOperationsAfterCounter returns a count of finished MinimockStorage.GetAccountOperations invocations
func (mmGetAccountOperations *MinimockStorage) GetAccountOperationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccountOperations.afterGetAccountOperationsCounter)
}

// GetAccountOperationsBeforeCounter returns a count of MinimockStorage.GetAccountOperations invocations
func (mmGetAccountOperations *MinimockStorage) GetAccountOperationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccountOperations.beforeGetAccountOperationsCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.GetAccountOperations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccountOperations *mMinimockStorageGetAccountOperations) Calls() []*MinimockStorageGetAccountOperationsParams {
	mmGetAccountOperations.mutex.RLock()

	argCopy := make([]*MinimockStorageGetAccountOperationsParams, len(mmGetAccountOperations.callArgs))
	copy(argCopy, mmGetAccountOperations.callArgs)

	mmGetAccountOperations.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccountOperationsDone returns true if the count of the GetAccountOperations invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockGetAccountOperationsDone() bool {
	if m.GetAccountOperationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccountOperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccountOperationsMock.invocationsDone()
}

// MinimockGetAccountOperationsInspect logs each unmet expectation
func (m *MinimockStorage) MinimockGetAccountOperationsInspect() {
	for _, e := range m.GetAccountOperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.GetAccountOperations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAccountOperationsCounter := mm_atomic.LoadUint64(&m.afterGetAccountOperationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccountOperationsMock.defaultExpectation != nil && afterGetAccountOperationsCounter < 1 {
		if m.GetAccountOperationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.GetAccountOperations at\n%s", m.GetAccountOperationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.GetAccountOperations at\n%s with params: %#v", m.GetAccountOperationsMock.defaultExpectation.expectationOrigins.origin, *m.GetAccountOperationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccountOperations != nil && afterGetAccountOperationsCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.GetAccountOperations at\n%s", m.funcGetAccountOperationsOrigin)
	}

	if !m.GetAccountOperationsMock.invocationsDone() && afterGetAccountOperationsCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.GetAccountOperations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccountOperationsMock.expectedInvocations), m.GetAccountOperationsMock.expectedInvocationsOrigin, afterGetAccountOperationsCounter)
	}
}

type mMinimockStorageGetUser struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageGetUserExpectation
	expectations       []*MinimockStorageGetUserExpectation

	callArgs []*MinimockStorageGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageGetUserExpectation specifies expectation struct of the Storage.GetUser
type MinimockStorageGetUserExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageGetUserParams
	paramPtrs          *MinimockStorageGetUserParamPtrs
	expectationOrigins MinimockStorageGetUserExpectationOrigins
	results            *MinimockStorageGetUserResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageGetUserParams contains parameters of the Storage.GetUser
type MinimockStorageGetUserParams struct {
	ctx    context.Context
	userID string
}

// MinimockStorageGetUserParamPtrs contains pointers to parameters of the Storage.GetUser
type MinimockStorageGetUserParamPtrs struct {
	ctx    *context.Context
	userID *string
}

// MinimockStorageGetUserResults contains results of the Storage.GetUser
type MinimockStorageGetUserResults struct {
	up1 *domain.UserWithAccounts
	err error
}

// MinimockStorageGetUserOrigins contains origins of expectations of the Storage.GetUser
type MinimockStorageGetUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mMinimockStorageGetUser) Optional() *mMinimockStorageGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for Storage.GetUser
func (mmGetUser *mMinimockStorageGetUser) Expect(ctx context.Context, userID string) *mMinimockStorageGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &MinimockStorageGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &MinimockStorageGetUserParams{ctx, userID}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetUser
func (mmGetUser *mMinimockStorageGetUser) ExpectCtxParam1(ctx context.Context) *mMinimockStorageGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &MinimockStorageGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &MinimockStorageGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectUserIDParam2 sets up expected param userID for Storage.GetUser
func (mmGetUser *mMinimockStorageGetUser) ExpectUserIDParam2(userID string) *mMinimockStorageGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &MinimockStorageGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &MinimockStorageGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.userID = &userID
	mmGetUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetUser
func (mmGetUser *mMinimockStorageGetUser) Inspect(f func(ctx context.Context, userID string)) *mMinimockStorageGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for MinimockStorage.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Storage.GetUser
func (mmGetUser *mMinimockStorageGetUser) Return(up1 *domain.UserWithAccounts, err error) *MinimockStorage {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &MinimockStorageGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &MinimockStorageGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the Storage.GetUser method
func (mmGetUser *mMinimockStorageGetUser) Set(f func(ctx context.Context, userID string) (up1 *domain.UserWithAccounts, err error)) *MinimockStorage {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Storage.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Storage.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the Storage.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mMinimockStorageGetUser) When(ctx context.Context, userID string) *MinimockStorageGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("MinimockStorage.GetUser mock is already set by Set")
	}

	expectation := &MinimockStorageGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &MinimockStorageGetUserParams{ctx, userID},
		expectationOrigins: MinimockStorageGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetUser return parameters for the expectation previously defined by the When method
func (e *MinimockStorageGetUserExpectation) Then(up1 *domain.UserWithAccounts, err error) *MinimockStorage {
	e.results = &MinimockStorageGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times Storage.GetUser should be invoked
func (mmGetUser *mMinimockStorageGetUser) Times(n uint64) *mMinimockStorageGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of MinimockStorage.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mMinimockStorageGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_storage.Storage
func (mmGetUser *MinimockStorage) GetUser(ctx context.Context, userID string) (up1 *domain.UserWithAccounts, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, userID)
	}

	mm_params := MinimockStorageGetUserParams{ctx, userID}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageGetUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("MinimockStorage.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUser.t.Errorf("MinimockStorage.GetUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("MinimockStorage.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the MinimockStorage.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, userID)
	}
	mmGetUser.t.Fatalf("Unexpected call to MinimockStorage.GetUser. %v %v", ctx, userID)
	return
}

// GetUserAfterCounter returns a count of finished MinimockStorage.GetUser invocations
func (mmGetUser *MinimockStorage) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of MinimockStorage.GetUser invocations
func (mmGetUser *MinimockStorage) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mMinimockStorageGetUser) Calls() []*MinimockStorageGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*MinimockStorageGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *MinimockStorage) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mMinimockStorageGetUserByPhone struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageGetUserByPhoneExpectation
	expectations       []*MinimockStorageGetUserByPhoneExpectation

	callArgs []*MinimockStorageGetUserByPhoneParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageGetUserByPhoneExpectation specifies expectation struct of the Storage.GetUserByPhone
type MinimockStorageGetUserByPhoneExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageGetUserByPhoneParams
	paramPtrs          *MinimockStorageGetUserByPhoneParamPtrs
	expectationOrigins MinimockStorageGetUserByPhoneExpectationOrigins
	results            *MinimockStorageGetUserByPhoneResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageGetUserByPhoneParams contains parameters of the Storage.GetUserByPhone
type MinimockStorageGetUserByPhoneParams struct {
	ctx   context.Context
	phone string
}

// MinimockStorageGetUserByPhoneParamPtrs contains pointers to parameters of the Storage.GetUserByPhone
type MinimockStorageGetUserByPhoneParamPtrs struct {
	ctx   *context.Context
	phone *string
}

// MinimockStorageGetUserByPhoneResults contains results of the Storage.GetUserByPhone
type MinimockStorageGetUserByPhoneResults struct {
	up1 *domain.User
	err error
}

// MinimockStorageGetUserByPhoneOrigins contains origins of expectations of the Storage.GetUserByPhone
type MinimockStorageGetUserByPhoneExpectationOrigins struct {
	origin      string
	originCtx   string
	originPhone string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) Optional() *mMinimockStorageGetUserByPhone {
	mmGetUserByPhone.optional = true
	return mmGetUserByPhone
}

// Expect sets up expected params for Storage.GetUserByPhone
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) Expect(ctx context.Context, phone string) *mMinimockStorageGetUserByPhone {
	if mmGetUserByPhone.mock.funcGetUserByPhone != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by Set")
	}

	if mmGetUserByPhone.defaultExpectation == nil {
		mmGetUserByPhone.defaultExpectation = &MinimockStorageGetUserByPhoneExpectation{}
	}

	if mmGetUserByPhone.defaultExpectation.paramPtrs != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by ExpectParams functions")
	}

	mmGetUserByPhone.defaultExpectation.params = &MinimockStorageGetUserByPhoneParams{ctx, phone}
	mmGetUserByPhone.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByPhone.expectations {
		if minimock.Equal(e.params, mmGetUserByPhone.defaultExpectation.params) {
			mmGetUserByPhone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByPhone.defaultExpectation.params)
		}
	}

	return mmGetUserByPhone
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetUserByPhone
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) ExpectCtxParam1(ctx context.Context) *mMinimockStorageGetUserByPhone {
	if mmGetUserByPhone.mock.funcGetUserByPhone != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by Set")
	}

	if mmGetUserByPhone.defaultExpectation == nil {
		mmGetUserByPhone.defaultExpectation = &MinimockStorageGetUserByPhoneExpectation{}
	}

	if mmGetUserByPhone.defaultExpectation.params != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by Expect")
	}

	if mmGetUserByPhone.defaultExpectation.paramPtrs == nil {
		mmGetUserByPhone.defaultExpectation.paramPtrs = &MinimockStorageGetUserByPhoneParamPtrs{}
	}
	mmGetUserByPhone.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByPhone.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByPhone
}

// ExpectPhoneParam2 sets up expected param phone for Storage.GetUserByPhone
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) ExpectPhoneParam2(phone string) *mMinimockStorageGetUserByPhone {
	if mmGetUserByPhone.mock.funcGetUserByPhone != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by Set")
	}

	if mmGetUserByPhone.defaultExpectation == nil {
		mmGetUserByPhone.defaultExpectation = &MinimockStorageGetUserByPhoneExpectation{}
	}

	if mmGetUserByPhone.defaultExpectation.params != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by Expect")
	}

	if mmGetUserByPhone.defaultExpectation.paramPtrs == nil {
		mmGetUserByPhone.defaultExpectation.paramPtrs = &MinimockStorageGetUserByPhoneParamPtrs{}
	}
	mmGetUserByPhone.defaultExpectation.paramPtrs.phone = &phone
	mmGetUserByPhone.defaultExpectation.expectationOrigins.originPhone = minimock.CallerInfo(1)

	return mmGetUserByPhone
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetUserByPhone
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) Inspect(f func(ctx context.Context, phone string)) *mMinimockStorageGetUserByPhone {
	if mmGetUserByPhone.mock.inspectFuncGetUserByPhone != nil {
		mmGetUserByPhone.mock.t.Fatalf("Inspect function is already set for MinimockStorage.GetUserByPhone")
	}

	mmGetUserByPhone.mock.inspectFuncGetUserByPhone = f

	return mmGetUserByPhone
}

// Return sets up results that will be returned by Storage.GetUserByPhone
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) Return(up1 *domain.User, err error) *MinimockStorage {
	if mmGetUserByPhone.mock.funcGetUserByPhone != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by Set")
	}

	if mmGetUserByPhone.defaultExpectation == nil {
		mmGetUserByPhone.defaultExpectation = &MinimockStorageGetUserByPhoneExpectation{mock: mmGetUserByPhone.mock}
	}
	mmGetUserByPhone.defaultExpectation.results = &MinimockStorageGetUserByPhoneResults{up1, err}
	mmGetUserByPhone.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByPhone.mock
}

// Set uses given function f to mock the Storage.GetUserByPhone method
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) Set(f func(ctx context.Context, phone string) (up1 *domain.User, err error)) *MinimockStorage {
	if mmGetUserByPhone.defaultExpectation != nil {
		mmGetUserByPhone.mock.t.Fatalf("Default expectation is already set for the Storage.GetUserByPhone method")
	}

	if len(mmGetUserByPhone.expectations) > 0 {
		mmGetUserByPhone.mock.t.Fatalf("Some expectations are already set for the Storage.GetUserByPhone method")
	}

	mmGetUserByPhone.mock.funcGetUserByPhone = f
	mmGetUserByPhone.mock.funcGetUserByPhoneOrigin = minimock.CallerInfo(1)
	return mmGetUserByPhone.mock
}

// When sets expectation for the Storage.GetUserByPhone which will trigger the result defined by the following
// Then helper
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) When(ctx context.Context, phone string) *MinimockStorageGetUserByPhoneExpectation {
	if mmGetUserByPhone.mock.funcGetUserByPhone != nil {
		mmGetUserByPhone.mock.t.Fatalf("MinimockStorage.GetUserByPhone mock is already set by Set")
	}

	expectation := &MinimockStorageGetUserByPhoneExpectation{
		mock:               mmGetUserByPhone.mock,
		params:             &MinimockStorageGetUserByPhoneParams{ctx, phone},
		expectationOrigins: MinimockStorageGetUserByPhoneExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByPhone.expectations = append(mmGetUserByPhone.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetUserByPhone return parameters for the expectation previously defined by the When method
func (e *MinimockStorageGetUserByPhoneExpectation) Then(up1 *domain.User, err error) *MinimockStorage {
	e.results = &MinimockStorageGetUserByPhoneResults{up1, err}
	return e.mock
}

// Times sets number of times Storage.GetUserByPhone should be invoked
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) Times(n uint64) *mMinimockStorageGetUserByPhone {
	if n == 0 {
		mmGetUserByPhone.mock.t.Fatalf("Times of MinimockStorage.GetUserByPhone mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByPhone.expectedInvocations, n)
	mmGetUserByPhone.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByPhone
}

func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) invocationsDone() bool {
	if len(mmGetUserByPhone.expectations) == 0 && mmGetUserByPhone.defaultExpectation == nil && mmGetUserByPhone.mock.funcGetUserByPhone == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByPhone.mock.afterGetUserByPhoneCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByPhone.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByPhone implements mm_storage.Storage
func (mmGetUserByPhone *MinimockStorage) GetUserByPhone(ctx context.Context, phone string) (up1 *domain.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByPhone.beforeGetUserByPhoneCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByPhone.afterGetUserByPhoneCounter, 1)

	mmGetUserByPhone.t.Helper()

	if mmGetUserByPhone.inspectFuncGetUserByPhone != nil {
		mmGetUserByPhone.inspectFuncGetUserByPhone(ctx, phone)
	}

	mm_params := MinimockStorageGetUserByPhoneParams{ctx, phone}

	// Record call args
	mmGetUserByPhone.GetUserByPhoneMock.mutex.Lock()
	mmGetUserByPhone.GetUserByPhoneMock.callArgs = append(mmGetUserByPhone.GetUserByPhoneMock.callArgs, &mm_params)
	mmGetUserByPhone.GetUserByPhoneMock.mutex.Unlock()

	for _, e := range mmGetUserByPhone.GetUserByPhoneMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageGetUserByPhoneParams{ctx, phone}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByPhone.t.Errorf("MinimockStorage.GetUserByPhone got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.phone != nil && !minimock.Equal(*mm_want_ptrs.phone, mm_got.phone) {
				mmGetUserByPhone.t.Errorf("MinimockStorage.GetUserByPhone got unexpected parameter phone, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation.expectationOrigins.originPhone, *mm_want_ptrs.phone, mm_got.phone, minimock.Diff(*mm_want_ptrs.phone, mm_got.phone))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByPhone.t.Errorf("MinimockStorage.GetUserByPhone got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByPhone.GetUserByPhoneMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByPhone.t.Fatal("No results are set for the MinimockStorage.GetUserByPhone")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByPhone.funcGetUserByPhone != nil {
		return mmGetUserByPhone.funcGetUserByPhone(ctx, phone)
	}
	mmGetUserByPhone.t.Fatalf("Unexpected call to MinimockStorage.GetUserByPhone. %v %v", ctx, phone)
	return
}

// GetUserByPhoneAfterCounter returns a count of finished MinimockStorage.GetUserByPhone invocations
func (mmGetUserByPhone *MinimockStorage) GetUserByPhoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByPhone.afterGetUserByPhoneCounter)
}

// GetUserByPhoneBeforeCounter returns a count of MinimockStorage.GetUserByPhone invocations
func (mmGetUserByPhone *MinimockStorage) GetUserByPhoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByPhone.beforeGetUserByPhoneCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.GetUserByPhone.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByPhone *mMinimockStorageGetUserByPhone) Calls() []*MinimockStorageGetUserByPhoneParams {
	mmGetUserByPhone.mutex.RLock()

	argCopy := make([]*MinimockStorageGetUserByPhoneParams, len(mmGetUserByPhone.callArgs))
	copy(argCopy, mmGetUserByPhone.callArgs)

	mmGetUserByPhone.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByPhoneDone returns true if the count of the GetUserByPhone invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockGetUserByPhoneDone() bool {
	if m.GetUserByPhoneMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByPhoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByPhoneMock.invocationsDone()
}

// MinimockGetUserByPhoneInspect logs each unmet expectation
func (m *MinimockStorage) MinimockGetUserByPhoneInspect() {
	for _, e := range m.GetUserByPhoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.GetUserByPhone at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByPhoneCounter := mm_atomic.LoadUint64(&m.afterGetUserByPhoneCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByPhoneMock.defaultExpectation != nil && afterGetUserByPhoneCounter < 1 {
		if m.GetUserByPhoneMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.GetUserByPhone at\n%s", m.GetUserByPhoneMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.GetUserByPhone at\n%s with params: %#v", m.GetUserByPhoneMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByPhoneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByPhone != nil && afterGetUserByPhoneCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.GetUserByPhone at\n%s", m.funcGetUserByPhoneOrigin)
	}

	if !m.GetUserByPhoneMock.invocationsDone() && afterGetUserByPhoneCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.GetUserByPhone at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByPhoneMock.expectedInvocations), m.GetUserByPhoneMock.expectedInvocationsOrigin, afterGetUserByPhoneCounter)
	}
}

type mMinimockStorageGetUserSessions struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageGetUserSessionsExpectation
	expectations       []*MinimockStorageGetUserSessionsExpectation

	callArgs []*MinimockStorageGetUserSessionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageGetUserSessionsExpectation specifies expectation struct of the Storage.GetUserSessions
type MinimockStorageGetUserSessionsExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageGetUserSessionsParams
	paramPtrs          *MinimockStorageGetUserSessionsParamPtrs
	expectationOrigins MinimockStorageGetUserSessionsExpectationOrigins
	results            *MinimockStorageGetUserSessionsResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageGetUserSessionsParams contains parameters of the Storage.GetUserSessions
type MinimockStorageGetUserSessionsParams struct {
	ctx    context.Context
	userID string
}

// MinimockStorageGetUserSessionsParamPtrs contains pointers to parameters of the Storage.GetUserSessions
type MinimockStorageGetUserSessionsParamPtrs struct {
	ctx    *context.Context
	userID *string
}

// MinimockStorageGetUserSessionsResults contains results of the Storage.GetUserSessions
type MinimockStorageGetUserSessionsResults struct {
	sa1 []string
	err error
}

// MinimockStorageGetUserSessionsOrigins contains origins of expectations of the Storage.GetUserSessions
type MinimockStorageGetUserSessionsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserSessions *mMinimockStorageGetUserSessions) Optional() *mMinimockStorageGetUserSessions {
	mmGetUserSessions.optional = true
	return mmGetUserSessions
}

// Expect sets up expected params for Storage.GetUserSessions
func (mmGetUserSessions *mMinimockStorageGetUserSessions) Expect(ctx context.Context, userID string) *mMinimockStorageGetUserSessions {
	if mmGetUserSessions.mock.funcGetUserSessions != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by Set")
	}

	if mmGetUserSessions.defaultExpectation == nil {
		mmGetUserSessions.defaultExpectation = &MinimockStorageGetUserSessionsExpectation{}
	}

	if mmGetUserSessions.defaultExpectation.paramPtrs != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by ExpectParams functions")
	}

	mmGetUserSessions.defaultExpectation.params = &MinimockStorageGetUserSessionsParams{ctx, userID}
	mmGetUserSessions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserSessions.expectations {
		if minimock.Equal(e.params, mmGetUserSessions.defaultExpectation.params) {
			mmGetUserSessions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserSessions.defaultExpectation.params)
		}
	}

	return mmGetUserSessions
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetUserSessions
func (mmGetUserSessions *mMinimockStorageGetUserSessions) ExpectCtxParam1(ctx context.Context) *mMinimockStorageGetUserSessions {
	if mmGetUserSessions.mock.funcGetUserSessions != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by Set")
	}

	if mmGetUserSessions.defaultExpectation == nil {
		mmGetUserSessions.defaultExpectation = &MinimockStorageGetUserSessionsExpectation{}
	}

	if mmGetUserSessions.defaultExpectation.params != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by Expect")
	}

	if mmGetUserSessions.defaultExpectation.paramPtrs == nil {
		mmGetUserSessions.defaultExpectation.paramPtrs = &MinimockStorageGetUserSessionsParamPtrs{}
	}
	mmGetUserSessions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserSessions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserSessions
}

// ExpectUserIDParam2 sets up expected param userID for Storage.GetUserSessions
func (mmGetUserSessions *mMinimockStorageGetUserSessions) ExpectUserIDParam2(userID string) *mMinimockStorageGetUserSessions {
	if mmGetUserSessions.mock.funcGetUserSessions != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by Set")
	}

	if mmGetUserSessions.defaultExpectation == nil {
		mmGetUserSessions.defaultExpectation = &MinimockStorageGetUserSessionsExpectation{}
	}

	if mmGetUserSessions.defaultExpectation.params != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by Expect")
	}

	if mmGetUserSessions.defaultExpectation.paramPtrs == nil {
		mmGetUserSessions.defaultExpectation.paramPtrs = &MinimockStorageGetUserSessionsParamPtrs{}
	}
	mmGetUserSessions.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserSessions.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserSessions
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetUserSessions
func (mmGetUserSessions *mMinimockStorageGetUserSessions) Inspect(f func(ctx context.Context, userID string)) *mMinimockStorageGetUserSessions {
	if mmGetUserSessions.mock.inspectFuncGetUserSessions != nil {
		mmGetUserSessions.mock.t.Fatalf("Inspect function is already set for MinimockStorage.GetUserSessions")
	}

	mmGetUserSessions.mock.inspectFuncGetUserSessions = f

	return mmGetUserSessions
}

// Return sets up results that will be returned by Storage.GetUserSessions
func (mmGetUserSessions *mMinimockStorageGetUserSessions) Return(sa1 []string, err error) *MinimockStorage {
	if mmGetUserSessions.mock.funcGetUserSessions != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by Set")
	}

	if mmGetUserSessions.defaultExpectation == nil {
		mmGetUserSessions.defaultExpectation = &MinimockStorageGetUserSessionsExpectation{mock: mmGetUserSessions.mock}
	}
	mmGetUserSessions.defaultExpectation.results = &MinimockStorageGetUserSessionsResults{sa1, err}
	mmGetUserSessions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserSessions.mock
}

// Set uses given function f to mock the Storage.GetUserSessions method
func (mmGetUserSessions *mMinimockStorageGetUserSessions) Set(f func(ctx context.Context, userID string) (sa1 []string, err error)) *MinimockStorage {
	if mmGetUserSessions.defaultExpectation != nil {
		mmGetUserSessions.mock.t.Fatalf("Default expectation is already set for the Storage.GetUserSessions method")
	}

	if len(mmGetUserSessions.expectations) > 0 {
		mmGetUserSessions.mock.t.Fatalf("Some expectations are already set for the Storage.GetUserSessions method")
	}

	mmGetUserSessions.mock.funcGetUserSessions = f
	mmGetUserSessions.mock.funcGetUserSessionsOrigin = minimock.CallerInfo(1)
	return mmGetUserSessions.mock
}

// When sets expectation for the Storage.GetUserSessions which will trigger the result defined by the following
// Then helper
func (mmGetUserSessions *mMinimockStorageGetUserSessions) When(ctx context.Context, userID string) *MinimockStorageGetUserSessionsExpectation {
	if mmGetUserSessions.mock.funcGetUserSessions != nil {
		mmGetUserSessions.mock.t.Fatalf("MinimockStorage.GetUserSessions mock is already set by Set")
	}

	expectation := &MinimockStorageGetUserSessionsExpectation{
		mock:               mmGetUserSessions.mock,
		params:             &MinimockStorageGetUserSessionsParams{ctx, userID},
		expectationOrigins: MinimockStorageGetUserSessionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserSessions.expectations = append(mmGetUserSessions.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetUserSessions return parameters for the expectation previously defined by the When method
func (e *MinimockStorageGetUserSessionsExpectation) Then(sa1 []string, err error) *MinimockStorage {
	e.results = &MinimockStorageGetUserSessionsResults{sa1, err}
	return e.mock
}

// Times sets number of times Storage.GetUserSessions should be invoked
func (mmGetUserSessions *mMinimockStorageGetUserSessions) Times(n uint64) *mMinimockStorageGetUserSessions {
	if n == 0 {
		mmGetUserSessions.mock.t.Fatalf("Times of MinimockStorage.GetUserSessions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserSessions.expectedInvocations, n)
	mmGetUserSessions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserSessions
}

func (mmGetUserSessions *mMinimockStorageGetUserSessions) invocationsDone() bool {
	if len(mmGetUserSessions.expectations) == 0 && mmGetUserSessions.defaultExpectation == nil && mmGetUserSessions.mock.funcGetUserSessions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserSessions.mock.afterGetUserSessionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserSessions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserSessions implements mm_storage.Storage
func (mmGetUserSessions *MinimockStorage) GetUserSessions(ctx context.Context, userID string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetUserSessions.beforeGetUserSessionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserSessions.afterGetUserSessionsCounter, 1)

	mmGetUserSessions.t.Helper()

	if mmGetUserSessions.inspectFuncGetUserSessions != nil {
		mmGetUserSessions.inspectFuncGetUserSessions(ctx, userID)
	}

	mm_params := MinimockStorageGetUserSessionsParams{ctx, userID}

	// Record call args
	mmGetUserSessions.GetUserSessionsMock.mutex.Lock()
	mmGetUserSessions.GetUserSessionsMock.callArgs = append(mmGetUserSessions.GetUserSessionsMock.callArgs, &mm_params)
	mmGetUserSessions.GetUserSessionsMock.mutex.Unlock()

	for _, e := range mmGetUserSessions.GetUserSessionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetUserSessions.GetUserSessionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserSessions.GetUserSessionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserSessions.GetUserSessionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserSessions.GetUserSessionsMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageGetUserSessionsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserSessions.t.Errorf("MinimockStorage.GetUserSessions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserSessions.GetUserSessionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserSessions.t.Errorf("MinimockStorage.GetUserSessions got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserSessions.GetUserSessionsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserSessions.t.Errorf("MinimockStorage.GetUserSessions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserSessions.GetUserSessionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserSessions.GetUserSessionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserSessions.t.Fatal("No results are set for the MinimockStorage.GetUserSessions")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetUserSessions.funcGetUserSessions != nil {
		return mmGetUserSessions.funcGetUserSessions(ctx, userID)
	}
	mmGetUserSessions.t.Fatalf("Unexpected call to MinimockStorage.GetUserSessions. %v %v", ctx, userID)
	return
}

// GetUserSessionsAfterCounter returns a count of finished MinimockStorage.GetUserSessions invocations
func (mmGetUserSessions *MinimockStorage) GetUserSessionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserSessions.afterGetUserSessionsCounter)
}

// GetUserSessionsBeforeCounter returns a count of MinimockStorage.GetUserSessions invocations
func (mmGetUserSessions *MinimockStorage) GetUserSessionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserSessions.beforeGetUserSessionsCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.GetUserSessions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserSessions *mMinimockStorageGetUserSessions) Calls() []*MinimockStorageGetUserSessionsParams {
	mmGetUserSessions.mutex.RLock()

	argCopy := make([]*MinimockStorageGetUserSessionsParams, len(mmGetUserSessions.callArgs))
	copy(argCopy, mmGetUserSessions.callArgs)

	mmGetUserSessions.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserSessionsDone returns true if the count of the GetUserSessions invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockGetUserSessionsDone() bool {
	if m.GetUserSessionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserSessionsMock.invocationsDone()
}

// MinimockGetUserSessionsInspect logs each unmet expectation
func (m *MinimockStorage) MinimockGetUserSessionsInspect() {
	for _, e := range m.GetUserSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.GetUserSessions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserSessionsCounter := mm_atomic.LoadUint64(&m.afterGetUserSessionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserSessionsMock.defaultExpectation != nil && afterGetUserSessionsCounter < 1 {
		if m.GetUserSessionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.GetUserSessions at\n%s", m.GetUserSessionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.GetUserSessions at\n%s with params: %#v", m.GetUserSessionsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserSessionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserSessions != nil && afterGetUserSessionsCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.GetUserSessions at\n%s", m.funcGetUserSessionsOrigin)
	}

	if !m.GetUserSessionsMock.invocationsDone() && afterGetUserSessionsCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.GetUserSessions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserSessionsMock.expectedInvocations), m.GetUserSessionsMock.expectedInvocationsOrigin, afterGetUserSessionsCounter)
	}
}

type mMinimockStorageLogIn struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageLogInExpectation
	expectations       []*MinimockStorageLogInExpectation

	callArgs []*MinimockStorageLogInParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageLogInExpectation specifies expectation struct of the Storage.LogIn
type MinimockStorageLogInExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageLogInParams
	paramPtrs          *MinimockStorageLogInParamPtrs
	expectationOrigins MinimockStorageLogInExpectationOrigins
	results            *MinimockStorageLogInResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageLogInParams contains parameters of the Storage.LogIn
type MinimockStorageLogInParams struct {
	ctx    context.Context
	userID string
	token  string
}

// MinimockStorageLogInParamPtrs contains pointers to parameters of the Storage.LogIn
type MinimockStorageLogInParamPtrs struct {
	ctx    *context.Context
	userID *string
	token  *string
}

// MinimockStorageLogInResults contains results of the Storage.LogIn
type MinimockStorageLogInResults struct {
	err error
}

// MinimockStorageLogInOrigins contains origins of expectations of the Storage.LogIn
type MinimockStorageLogInExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originToken  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogIn *mMinimockStorageLogIn) Optional() *mMinimockStorageLogIn {
	mmLogIn.optional = true
	return mmLogIn
}

// Expect sets up expected params for Storage.LogIn
func (mmLogIn *mMinimockStorageLogIn) Expect(ctx context.Context, userID string, token string) *mMinimockStorageLogIn {
	if mmLogIn.mock.funcLogIn != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Set")
	}

	if mmLogIn.defaultExpectation == nil {
		mmLogIn.defaultExpectation = &MinimockStorageLogInExpectation{}
	}

	if mmLogIn.defaultExpectation.paramPtrs != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by ExpectParams functions")
	}

	mmLogIn.defaultExpectation.params = &MinimockStorageLogInParams{ctx, userID, token}
	mmLogIn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogIn.expectations {
		if minimock.Equal(e.params, mmLogIn.defaultExpectation.params) {
			mmLogIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogIn.defaultExpectation.params)
		}
	}

	return mmLogIn
}

// ExpectCtxParam1 sets up expected param ctx for Storage.LogIn
func (mmLogIn *mMinimockStorageLogIn) ExpectCtxParam1(ctx context.Context) *mMinimockStorageLogIn {
	if mmLogIn.mock.funcLogIn != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Set")
	}

	if mmLogIn.defaultExpectation == nil {
		mmLogIn.defaultExpectation = &MinimockStorageLogInExpectation{}
	}

	if mmLogIn.defaultExpectation.params != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Expect")
	}

	if mmLogIn.defaultExpectation.paramPtrs == nil {
		mmLogIn.defaultExpectation.paramPtrs = &MinimockStorageLogInParamPtrs{}
	}
	mmLogIn.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogIn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogIn
}

// ExpectUserIDParam2 sets up expected param userID for Storage.LogIn
func (mmLogIn *mMinimockStorageLogIn) ExpectUserIDParam2(userID string) *mMinimockStorageLogIn {
	if mmLogIn.mock.funcLogIn != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Set")
	}

	if mmLogIn.defaultExpectation == nil {
		mmLogIn.defaultExpectation = &MinimockStorageLogInExpectation{}
	}

	if mmLogIn.defaultExpectation.params != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Expect")
	}

	if mmLogIn.defaultExpectation.paramPtrs == nil {
		mmLogIn.defaultExpectation.paramPtrs = &MinimockStorageLogInParamPtrs{}
	}
	mmLogIn.defaultExpectation.paramPtrs.userID = &userID
	mmLogIn.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmLogIn
}

// ExpectTokenParam3 sets up expected param token for Storage.LogIn
func (mmLogIn *mMinimockStorageLogIn) ExpectTokenParam3(token string) *mMinimockStorageLogIn {
	if mmLogIn.mock.funcLogIn != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Set")
	}

	if mmLogIn.defaultExpectation == nil {
		mmLogIn.defaultExpectation = &MinimockStorageLogInExpectation{}
	}

	if mmLogIn.defaultExpectation.params != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Expect")
	}

	if mmLogIn.defaultExpectation.paramPtrs == nil {
		mmLogIn.defaultExpectation.paramPtrs = &MinimockStorageLogInParamPtrs{}
	}
	mmLogIn.defaultExpectation.paramPtrs.token = &token
	mmLogIn.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmLogIn
}

// Inspect accepts an inspector function that has same arguments as the Storage.LogIn
func (mmLogIn *mMinimockStorageLogIn) Inspect(f func(ctx context.Context, userID string, token string)) *mMinimockStorageLogIn {
	if mmLogIn.mock.inspectFuncLogIn != nil {
		mmLogIn.mock.t.Fatalf("Inspect function is already set for MinimockStorage.LogIn")
	}

	mmLogIn.mock.inspectFuncLogIn = f

	return mmLogIn
}

// Return sets up results that will be returned by Storage.LogIn
func (mmLogIn *mMinimockStorageLogIn) Return(err error) *MinimockStorage {
	if mmLogIn.mock.funcLogIn != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Set")
	}

	if mmLogIn.defaultExpectation == nil {
		mmLogIn.defaultExpectation = &MinimockStorageLogInExpectation{mock: mmLogIn.mock}
	}
	mmLogIn.defaultExpectation.results = &MinimockStorageLogInResults{err}
	mmLogIn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogIn.mock
}

// Set uses given function f to mock the Storage.LogIn method
func (mmLogIn *mMinimockStorageLogIn) Set(f func(ctx context.Context, userID string, token string) (err error)) *MinimockStorage {
	if mmLogIn.defaultExpectation != nil {
		mmLogIn.mock.t.Fatalf("Default expectation is already set for the Storage.LogIn method")
	}

	if len(mmLogIn.expectations) > 0 {
		mmLogIn.mock.t.Fatalf("Some expectations are already set for the Storage.LogIn method")
	}

	mmLogIn.mock.funcLogIn = f
	mmLogIn.mock.funcLogInOrigin = minimock.CallerInfo(1)
	return mmLogIn.mock
}

// When sets expectation for the Storage.LogIn which will trigger the result defined by the following
// Then helper
func (mmLogIn *mMinimockStorageLogIn) When(ctx context.Context, userID string, token string) *MinimockStorageLogInExpectation {
	if mmLogIn.mock.funcLogIn != nil {
		mmLogIn.mock.t.Fatalf("MinimockStorage.LogIn mock is already set by Set")
	}

	expectation := &MinimockStorageLogInExpectation{
		mock:               mmLogIn.mock,
		params:             &MinimockStorageLogInParams{ctx, userID, token},
		expectationOrigins: MinimockStorageLogInExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogIn.expectations = append(mmLogIn.expectations, expectation)
	return expectation
}

// Then sets up Storage.LogIn return parameters for the expectation previously defined by the When method
func (e *MinimockStorageLogInExpectation) Then(err error) *MinimockStorage {
	e.results = &MinimockStorageLogInResults{err}
	return e.mock
}

// Times sets number of times Storage.LogIn should be invoked
func (mmLogIn *mMinimockStorageLogIn) Times(n uint64) *mMinimockStorageLogIn {
	if n == 0 {
		mmLogIn.mock.t.Fatalf("Times of MinimockStorage.LogIn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogIn.expectedInvocations, n)
	mmLogIn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogIn
}

func (mmLogIn *mMinimockStorageLogIn) invocationsDone() bool {
	if len(mmLogIn.expectations) == 0 && mmLogIn.defaultExpectation == nil && mmLogIn.mock.funcLogIn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogIn.mock.afterLogInCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogIn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LogIn implements mm_storage.Storage
func (mmLogIn *MinimockStorage) LogIn(ctx context.Context, userID string, token string) (err error) {
	mm_atomic.AddUint64(&mmLogIn.beforeLogInCounter, 1)
	defer mm_atomic.AddUint64(&mmLogIn.afterLogInCounter, 1)

	mmLogIn.t.Helper()

	if mmLogIn.inspectFuncLogIn != nil {
		mmLogIn.inspectFuncLogIn(ctx, userID, token)
	}

	mm_params := MinimockStorageLogInParams{ctx, userID, token}

	// Record call args
	mmLogIn.LogInMock.mutex.Lock()
	mmLogIn.LogInMock.callArgs = append(mmLogIn.LogInMock.callArgs, &mm_params)
	mmLogIn.LogInMock.mutex.Unlock()

	for _, e := range mmLogIn.LogInMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLogIn.LogInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogIn.LogInMock.defaultExpectation.Counter, 1)
		mm_want := mmLogIn.LogInMock.defaultExpectation.params
		mm_want_ptrs := mmLogIn.LogInMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageLogInParams{ctx, userID, token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogIn.t.Errorf("MinimockStorage.LogIn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogIn.LogInMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmLogIn.t.Errorf("MinimockStorage.LogIn got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogIn.LogInMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmLogIn.t.Errorf("MinimockStorage.LogIn got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogIn.LogInMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogIn.t.Errorf("MinimockStorage.LogIn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogIn.LogInMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogIn.LogInMock.defaultExpectation.results
		if mm_results == nil {
			mmLogIn.t.Fatal("No results are set for the MinimockStorage.LogIn")
		}
		return (*mm_results).err
	}
	if mmLogIn.funcLogIn != nil {
		return mmLogIn.funcLogIn(ctx, userID, token)
	}
	mmLogIn.t.Fatalf("Unexpected call to MinimockStorage.LogIn. %v %v %v", ctx, userID, token)
	return
}

// LogInAfterCounter returns a count of finished MinimockStorage.LogIn invocations
func (mmLogIn *MinimockStorage) LogInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogIn.afterLogInCounter)
}

// LogInBeforeCounter returns a count of MinimockStorage.LogIn invocations
func (mmLogIn *MinimockStorage) LogInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogIn.beforeLogInCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.LogIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogIn *mMinimockStorageLogIn) Calls() []*MinimockStorageLogInParams {
	mmLogIn.mutex.RLock()

	argCopy := make([]*MinimockStorageLogInParams, len(mmLogIn.callArgs))
	copy(argCopy, mmLogIn.callArgs)

	mmLogIn.mutex.RUnlock()

	return argCopy
}

// MinimockLogInDone returns true if the count of the LogIn invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockLogInDone() bool {
	if m.LogInMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogInMock.invocationsDone()
}

// MinimockLogInInspect logs each unmet expectation
func (m *MinimockStorage) MinimockLogInInspect() {
	for _, e := range m.LogInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.LogIn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogInCounter := mm_atomic.LoadUint64(&m.afterLogInCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogInMock.defaultExpectation != nil && afterLogInCounter < 1 {
		if m.LogInMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.LogIn at\n%s", m.LogInMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.LogIn at\n%s with params: %#v", m.LogInMock.defaultExpectation.expectationOrigins.origin, *m.LogInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogIn != nil && afterLogInCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.LogIn at\n%s", m.funcLogInOrigin)
	}

	if !m.LogInMock.invocationsDone() && afterLogInCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.LogIn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogInMock.expectedInvocations), m.LogInMock.expectedInvocationsOrigin, afterLogInCounter)
	}
}

type mMinimockStorageUpgradeUser struct {
	optional           bool
	mock               *MinimockStorage
	defaultExpectation *MinimockStorageUpgradeUserExpectation
	expectations       []*MinimockStorageUpgradeUserExpectation

	callArgs []*MinimockStorageUpgradeUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinimockStorageUpgradeUserExpectation specifies expectation struct of the Storage.UpgradeUser
type MinimockStorageUpgradeUserExpectation struct {
	mock               *MinimockStorage
	params             *MinimockStorageUpgradeUserParams
	paramPtrs          *MinimockStorageUpgradeUserParamPtrs
	expectationOrigins MinimockStorageUpgradeUserExpectationOrigins
	results            *MinimockStorageUpgradeUserResults
	returnOrigin       string
	Counter            uint64
}

// MinimockStorageUpgradeUserParams contains parameters of the Storage.UpgradeUser
type MinimockStorageUpgradeUserParams struct {
	ctx    context.Context
	userID string
	level  string
}

// MinimockStorageUpgradeUserParamPtrs contains pointers to parameters of the Storage.UpgradeUser
type MinimockStorageUpgradeUserParamPtrs struct {
	ctx    *context.Context
	userID *string
	level  *string
}

// MinimockStorageUpgradeUserResults contains results of the Storage.UpgradeUser
type MinimockStorageUpgradeUserResults struct {
	err error
}

// MinimockStorageUpgradeUserOrigins contains origins of expectations of the Storage.UpgradeUser
type MinimockStorageUpgradeUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originLevel  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpgradeUser *mMinimockStorageUpgradeUser) Optional() *mMinimockStorageUpgradeUser {
	mmUpgradeUser.optional = true
	return mmUpgradeUser
}

// Expect sets up expected params for Storage.UpgradeUser
func (mmUpgradeUser *mMinimockStorageUpgradeUser) Expect(ctx context.Context, userID string, level string) *mMinimockStorageUpgradeUser {
	if mmUpgradeUser.mock.funcUpgradeUser != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Set")
	}

	if mmUpgradeUser.defaultExpectation == nil {
		mmUpgradeUser.defaultExpectation = &MinimockStorageUpgradeUserExpectation{}
	}

	if mmUpgradeUser.defaultExpectation.paramPtrs != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by ExpectParams functions")
	}

	mmUpgradeUser.defaultExpectation.params = &MinimockStorageUpgradeUserParams{ctx, userID, level}
	mmUpgradeUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpgradeUser.expectations {
		if minimock.Equal(e.params, mmUpgradeUser.defaultExpectation.params) {
			mmUpgradeUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpgradeUser.defaultExpectation.params)
		}
	}

	return mmUpgradeUser
}

// ExpectCtxParam1 sets up expected param ctx for Storage.UpgradeUser
func (mmUpgradeUser *mMinimockStorageUpgradeUser) ExpectCtxParam1(ctx context.Context) *mMinimockStorageUpgradeUser {
	if mmUpgradeUser.mock.funcUpgradeUser != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Set")
	}

	if mmUpgradeUser.defaultExpectation == nil {
		mmUpgradeUser.defaultExpectation = &MinimockStorageUpgradeUserExpectation{}
	}

	if mmUpgradeUser.defaultExpectation.params != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Expect")
	}

	if mmUpgradeUser.defaultExpectation.paramPtrs == nil {
		mmUpgradeUser.defaultExpectation.paramPtrs = &MinimockStorageUpgradeUserParamPtrs{}
	}
	mmUpgradeUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpgradeUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpgradeUser
}

// ExpectUserIDParam2 sets up expected param userID for Storage.UpgradeUser
func (mmUpgradeUser *mMinimockStorageUpgradeUser) ExpectUserIDParam2(userID string) *mMinimockStorageUpgradeUser {
	if mmUpgradeUser.mock.funcUpgradeUser != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Set")
	}

	if mmUpgradeUser.defaultExpectation == nil {
		mmUpgradeUser.defaultExpectation = &MinimockStorageUpgradeUserExpectation{}
	}

	if mmUpgradeUser.defaultExpectation.params != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Expect")
	}

	if mmUpgradeUser.defaultExpectation.paramPtrs == nil {
		mmUpgradeUser.defaultExpectation.paramPtrs = &MinimockStorageUpgradeUserParamPtrs{}
	}
	mmUpgradeUser.defaultExpectation.paramPtrs.userID = &userID
	mmUpgradeUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpgradeUser
}

// ExpectLevelParam3 sets up expected param level for Storage.UpgradeUser
func (mmUpgradeUser *mMinimockStorageUpgradeUser) ExpectLevelParam3(level string) *mMinimockStorageUpgradeUser {
	if mmUpgradeUser.mock.funcUpgradeUser != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Set")
	}

	if mmUpgradeUser.defaultExpectation == nil {
		mmUpgradeUser.defaultExpectation = &MinimockStorageUpgradeUserExpectation{}
	}

	if mmUpgradeUser.defaultExpectation.params != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Expect")
	}

	if mmUpgradeUser.defaultExpectation.paramPtrs == nil {
		mmUpgradeUser.defaultExpectation.paramPtrs = &MinimockStorageUpgradeUserParamPtrs{}
	}
	mmUpgradeUser.defaultExpectation.paramPtrs.level = &level
	mmUpgradeUser.defaultExpectation.expectationOrigins.originLevel = minimock.CallerInfo(1)

	return mmUpgradeUser
}

// Inspect accepts an inspector function that has same arguments as the Storage.UpgradeUser
func (mmUpgradeUser *mMinimockStorageUpgradeUser) Inspect(f func(ctx context.Context, userID string, level string)) *mMinimockStorageUpgradeUser {
	if mmUpgradeUser.mock.inspectFuncUpgradeUser != nil {
		mmUpgradeUser.mock.t.Fatalf("Inspect function is already set for MinimockStorage.UpgradeUser")
	}

	mmUpgradeUser.mock.inspectFuncUpgradeUser = f

	return mmUpgradeUser
}

// Return sets up results that will be returned by Storage.UpgradeUser
func (mmUpgradeUser *mMinimockStorageUpgradeUser) Return(err error) *MinimockStorage {
	if mmUpgradeUser.mock.funcUpgradeUser != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Set")
	}

	if mmUpgradeUser.defaultExpectation == nil {
		mmUpgradeUser.defaultExpectation = &MinimockStorageUpgradeUserExpectation{mock: mmUpgradeUser.mock}
	}
	mmUpgradeUser.defaultExpectation.results = &MinimockStorageUpgradeUserResults{err}
	mmUpgradeUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpgradeUser.mock
}

// Set uses given function f to mock the Storage.UpgradeUser method
func (mmUpgradeUser *mMinimockStorageUpgradeUser) Set(f func(ctx context.Context, userID string, level string) (err error)) *MinimockStorage {
	if mmUpgradeUser.defaultExpectation != nil {
		mmUpgradeUser.mock.t.Fatalf("Default expectation is already set for the Storage.UpgradeUser method")
	}

	if len(mmUpgradeUser.expectations) > 0 {
		mmUpgradeUser.mock.t.Fatalf("Some expectations are already set for the Storage.UpgradeUser method")
	}

	mmUpgradeUser.mock.funcUpgradeUser = f
	mmUpgradeUser.mock.funcUpgradeUserOrigin = minimock.CallerInfo(1)
	return mmUpgradeUser.mock
}

// When sets expectation for the Storage.UpgradeUser which will trigger the result defined by the following
// Then helper
func (mmUpgradeUser *mMinimockStorageUpgradeUser) When(ctx context.Context, userID string, level string) *MinimockStorageUpgradeUserExpectation {
	if mmUpgradeUser.mock.funcUpgradeUser != nil {
		mmUpgradeUser.mock.t.Fatalf("MinimockStorage.UpgradeUser mock is already set by Set")
	}

	expectation := &MinimockStorageUpgradeUserExpectation{
		mock:               mmUpgradeUser.mock,
		params:             &MinimockStorageUpgradeUserParams{ctx, userID, level},
		expectationOrigins: MinimockStorageUpgradeUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpgradeUser.expectations = append(mmUpgradeUser.expectations, expectation)
	return expectation
}

// Then sets up Storage.UpgradeUser return parameters for the expectation previously defined by the When method
func (e *MinimockStorageUpgradeUserExpectation) Then(err error) *MinimockStorage {
	e.results = &MinimockStorageUpgradeUserResults{err}
	return e.mock
}

// Times sets number of times Storage.UpgradeUser should be invoked
func (mmUpgradeUser *mMinimockStorageUpgradeUser) Times(n uint64) *mMinimockStorageUpgradeUser {
	if n == 0 {
		mmUpgradeUser.mock.t.Fatalf("Times of MinimockStorage.UpgradeUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpgradeUser.expectedInvocations, n)
	mmUpgradeUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpgradeUser
}

func (mmUpgradeUser *mMinimockStorageUpgradeUser) invocationsDone() bool {
	if len(mmUpgradeUser.expectations) == 0 && mmUpgradeUser.defaultExpectation == nil && mmUpgradeUser.mock.funcUpgradeUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpgradeUser.mock.afterUpgradeUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpgradeUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpgradeUser implements mm_storage.Storage
func (mmUpgradeUser *MinimockStorage) UpgradeUser(ctx context.Context, userID string, level string) (err error) {
	mm_atomic.AddUint64(&mmUpgradeUser.beforeUpgradeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpgradeUser.afterUpgradeUserCounter, 1)

	mmUpgradeUser.t.Helper()

	if mmUpgradeUser.inspectFuncUpgradeUser != nil {
		mmUpgradeUser.inspectFuncUpgradeUser(ctx, userID, level)
	}

	mm_params := MinimockStorageUpgradeUserParams{ctx, userID, level}

	// Record call args
	mmUpgradeUser.UpgradeUserMock.mutex.Lock()
	mmUpgradeUser.UpgradeUserMock.callArgs = append(mmUpgradeUser.UpgradeUserMock.callArgs, &mm_params)
	mmUpgradeUser.UpgradeUserMock.mutex.Unlock()

	for _, e := range mmUpgradeUser.UpgradeUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpgradeUser.UpgradeUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpgradeUser.UpgradeUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpgradeUser.UpgradeUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpgradeUser.UpgradeUserMock.defaultExpectation.paramPtrs

		mm_got := MinimockStorageUpgradeUserParams{ctx, userID, level}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpgradeUser.t.Errorf("MinimockStorage.UpgradeUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpgradeUser.UpgradeUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpgradeUser.t.Errorf("MinimockStorage.UpgradeUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpgradeUser.UpgradeUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.level != nil && !minimock.Equal(*mm_want_ptrs.level, mm_got.level) {
				mmUpgradeUser.t.Errorf("MinimockStorage.UpgradeUser got unexpected parameter level, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpgradeUser.UpgradeUserMock.defaultExpectation.expectationOrigins.originLevel, *mm_want_ptrs.level, mm_got.level, minimock.Diff(*mm_want_ptrs.level, mm_got.level))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpgradeUser.t.Errorf("MinimockStorage.UpgradeUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpgradeUser.UpgradeUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpgradeUser.UpgradeUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpgradeUser.t.Fatal("No results are set for the MinimockStorage.UpgradeUser")
		}
		return (*mm_results).err
	}
	if mmUpgradeUser.funcUpgradeUser != nil {
		return mmUpgradeUser.funcUpgradeUser(ctx, userID, level)
	}
	mmUpgradeUser.t.Fatalf("Unexpected call to MinimockStorage.UpgradeUser. %v %v %v", ctx, userID, level)
	return
}

// UpgradeUserAfterCounter returns a count of finished MinimockStorage.UpgradeUser invocations
func (mmUpgradeUser *MinimockStorage) UpgradeUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpgradeUser.afterUpgradeUserCounter)
}

// UpgradeUserBeforeCounter returns a count of MinimockStorage.UpgradeUser invocations
func (mmUpgradeUser *MinimockStorage) UpgradeUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpgradeUser.beforeUpgradeUserCounter)
}

// Calls returns a list of arguments used in each call to MinimockStorage.UpgradeUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpgradeUser *mMinimockStorageUpgradeUser) Calls() []*MinimockStorageUpgradeUserParams {
	mmUpgradeUser.mutex.RLock()

	argCopy := make([]*MinimockStorageUpgradeUserParams, len(mmUpgradeUser.callArgs))
	copy(argCopy, mmUpgradeUser.callArgs)

	mmUpgradeUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpgradeUserDone returns true if the count of the UpgradeUser invocations corresponds
// the number of defined expectations
func (m *MinimockStorage) MinimockUpgradeUserDone() bool {
	if m.UpgradeUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpgradeUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpgradeUserMock.invocationsDone()
}

// MinimockUpgradeUserInspect logs each unmet expectation
func (m *MinimockStorage) MinimockUpgradeUserInspect() {
	for _, e := range m.UpgradeUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinimockStorage.UpgradeUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpgradeUserCounter := mm_atomic.LoadUint64(&m.afterUpgradeUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpgradeUserMock.defaultExpectation != nil && afterUpgradeUserCounter < 1 {
		if m.UpgradeUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinimockStorage.UpgradeUser at\n%s", m.UpgradeUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinimockStorage.UpgradeUser at\n%s with params: %#v", m.UpgradeUserMock.defaultExpectation.expectationOrigins.origin, *m.UpgradeUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpgradeUser != nil && afterUpgradeUserCounter < 1 {
		m.t.Errorf("Expected call to MinimockStorage.UpgradeUser at\n%s", m.funcUpgradeUserOrigin)
	}

	if !m.UpgradeUserMock.invocationsDone() && afterUpgradeUserCounter > 0 {
		m.t.Errorf("Expected %d calls to MinimockStorage.UpgradeUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpgradeUserMock.expectedInvocations), m.UpgradeUserMock.expectedInvocationsOrigin, afterUpgradeUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MinimockStorage) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddAccountInspect()

			m.MinimockCollectOperationInspect()

			m.MinimockCreateUserInspect()

			m.MinimockCreditInspect()

			m.MinimockDebitInspect()

			m.MinimockExecInspect()

			m.MinimockGetAccountInspect()

			m.MinimockGetAccountOperationsInspect()

			m.MinimockGetUserInspect()

			m.MinimockGetUserByPhoneInspect()

			m.MinimockGetUserSessionsInspect()

			m.MinimockLogInInspect()

			m.MinimockUpgradeUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MinimockStorage) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MinimockStorage) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddAccountDone() &&
		m.MinimockCollectOperationDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockCreditDone() &&
		m.MinimockDebitDone() &&
		m.MinimockExecDone() &&
		m.MinimockGetAccountDone() &&
		m.MinimockGetAccountOperationsDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockGetUserByPhoneDone() &&
		m.MinimockGetUserSessionsDone() &&
		m.MinimockLogInDone() &&
		m.MinimockUpgradeUserDone()
}
