
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>wallet: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.ozon.dev/route256/wallet/internal/app/wallet/collect_operation.go (100.0%)</option>
				
				<option value="file1">gitlab.ozon.dev/route256/wallet/internal/app/wallet/creaet_account.go (92.3%)</option>
				
				<option value="file2">gitlab.ozon.dev/route256/wallet/internal/app/wallet/create_user.go (100.0%)</option>
				
				<option value="file3">gitlab.ozon.dev/route256/wallet/internal/app/wallet/credit.go (94.1%)</option>
				
				<option value="file4">gitlab.ozon.dev/route256/wallet/internal/app/wallet/debit.go (94.7%)</option>
				
				<option value="file5">gitlab.ozon.dev/route256/wallet/internal/app/wallet/force_collect_operation.go (100.0%)</option>
				
				<option value="file6">gitlab.ozon.dev/route256/wallet/internal/app/wallet/get_account_balance.go (100.0%)</option>
				
				<option value="file7">gitlab.ozon.dev/route256/wallet/internal/app/wallet/get_exchange_rates.go (100.0%)</option>
				
				<option value="file8">gitlab.ozon.dev/route256/wallet/internal/app/wallet/get_user.go (83.3%)</option>
				
				<option value="file9">gitlab.ozon.dev/route256/wallet/internal/app/wallet/kafka_comsume.go (91.7%)</option>
				
				<option value="file10">gitlab.ozon.dev/route256/wallet/internal/app/wallet/kafka_produce_.go (91.7%)</option>
				
				<option value="file11">gitlab.ozon.dev/route256/wallet/internal/app/wallet/log_in.go (92.3%)</option>
				
				<option value="file12">gitlab.ozon.dev/route256/wallet/internal/app/wallet/upgrade_user.go (90.9%)</option>
				
				<option value="file13">gitlab.ozon.dev/route256/wallet/internal/pkg/cbr/client.go (76.5%)</option>
				
				<option value="file14">gitlab.ozon.dev/route256/wallet/internal/pkg/cbr/valutes/valutes.go (83.3%)</option>
				
				<option value="file15">gitlab.ozon.dev/route256/wallet/internal/pkg/domain/user.go (100.0%)</option>
				
				<option value="file16">gitlab.ozon.dev/route256/wallet/internal/pkg/kafka/kafka.go (0.0%)</option>
				
				<option value="file17">gitlab.ozon.dev/route256/wallet/internal/pkg/kafka/messages.go (88.9%)</option>
				
				<option value="file18">gitlab.ozon.dev/route256/wallet/internal/pkg/storage/account.go (76.5%)</option>
				
				<option value="file19">gitlab.ozon.dev/route256/wallet/internal/pkg/storage/account_operations.go (71.1%)</option>
				
				<option value="file20">gitlab.ozon.dev/route256/wallet/internal/pkg/storage/storage.go (76.5%)</option>
				
				<option value="file21">gitlab.ozon.dev/route256/wallet/internal/pkg/storage/user.go (75.9%)</option>
				
				<option value="file22">gitlab.ozon.dev/route256/wallet/internal/pkg/testutils/testutils.go (81.0%)</option>
				
				<option value="file23">gitlab.ozon.dev/route256/wallet/internal/pkg/token/token.go (61.9%)</option>
				
				<option value="file24">gitlab.ozon.dev/route256/wallet/internal/pkg/utils/password.go (100.0%)</option>
				
				<option value="file25">gitlab.ozon.dev/route256/wallet/internal/pkg/worker/collect.go (0.0%)</option>
				
				<option value="file26">gitlab.ozon.dev/route256/wallet/internal/server/gatawey.go (0.0%)</option>
				
				<option value="file27">gitlab.ozon.dev/route256/wallet/internal/server/logging.go (0.0%)</option>
				
				<option value="file28">gitlab.ozon.dev/route256/wallet/internal/server/metrics.go (0.0%)</option>
				
				<option value="file29">gitlab.ozon.dev/route256/wallet/internal/server/server.go (0.0%)</option>
				
				<option value="file30">gitlab.ozon.dev/route256/wallet/internal/server/status.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package wallet

import (
        "context"

        "gitlab.ozon.dev/route256/wallet/internal/pkg/worker"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
)

// CollectOperation Подсчет колличества операций
func (i *Implementation) CollectOperation(_ context.Context, _ *desc.OperationCountRequest) (*desc.OperationCountResponse, error) <span class="cov10" title="3">{
        return &amp;desc.OperationCountResponse{OperationsCount: worker.Count.Load()}, nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package wallet

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// CreateAccount Создать счет
func (i *Implementation) CreateAccount(ctx context.Context, req *desc.CreateAccountRequest) (*desc.CreateAccountResponse, error) <span class="cov10" title="15">{
        if err := i.CheckToken(ctx, req.UserId); err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="12">user, err := i.User(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="12">if len(user.Accounts) == 3 </span><span class="cov4" title="3">{
                return nil, status.Error(codes.AlreadyExists, "User allready has 3 accounts")
        }</span>

        <span class="cov8" title="9">acc := &amp;domain.Account{
                UserID:      user.ID,
                AccountID:   uuid.NewString(),
                Amount:      req.GetAmount(),
                Description: req.GetDescription(),
        }
        err = i.store.AddAccount(ctx, acc)
        if err != nil </span><span class="cov4" title="3">{
                log.Error()
                return nil, status.Error(codes.Internal, fmt.Sprintf("Create account err: %v", err))
        }</span>

        <span class="cov6" title="6">return &amp;desc.CreateAccountResponse{
                AccountId:   acc.AccountID,
                Amount:      acc.Amount,
                Description: acc.Description,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package wallet

import (
        "context"
        "fmt"
        "regexp"

        "gitlab.ozon.dev/route256/wallet/internal/config"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/utils"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

var phonePattern = regexp.MustCompile(`8\d{10}`)

func (i *Implementation) CreateUser(ctx context.Context, req *desc.CreateUserRequest) (*desc.CreateUserResponse, error) <span class="cov10" title="9">{
        ok := phonePattern.MatchString(req.Phone)
        if !ok </span><span class="cov5" title="3">{
                return nil, status.Error(codes.InvalidArgument, "phone not match pattern 8xxxxxxxxxx")
        }</span>

        <span class="cov8" title="6">user := &amp;domain.User{
                Name:         req.Name,
                Lastname:     req.Lastname,
                Age:          req.Age,
                Phone:        req.Phone,
                PasswordHash: utils.GetPasswordHash(req.Password),
                Level:        config.ANON,
        }

        err := i.store.CreateUser(ctx, user)
        if err != nil </span><span class="cov5" title="3">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("CreateUser err: %v", err))
        }</span>

        <span class="cov5" title="3">return &amp;desc.CreateUserResponse{
                Info: &amp;desc.User{
                        Id:                  user.ID.String(),
                        Name:                user.Name,
                        Lastname:            user.Lastname,
                        Age:                 user.Age,
                        Phone:               user.Phone,
                        IdentificationLevel: desc.IdentificationLevel(desc.IdentificationLevel_value[user.Level]),
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package wallet

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// Credit списание денег
func (i *Implementation) Credit(ctx context.Context, req *desc.CreditRequest) (*desc.CreditResponse, error) <span class="cov10" title="24">{
        if err := i.CheckToken(ctx, req.UserId); err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="21">user, err := i.User(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="21">account, ok := user.GetAccount(req.GetAccountId())
        if !ok </span><span class="cov4" title="3">{
                return nil, status.Error(codes.NotFound, "account not found")
        }</span>

        <span class="cov9" title="18">if account.Amount-req.GetAmount() &lt; 0 </span><span class="cov6" title="6">{
                return &amp;desc.CreditResponse{
                        Status: desc.OperationStatus_STATUS_FAIL,
                }, status.Error(codes.InvalidArgument, "unavailable operation")
        }</span>

        <span class="cov8" title="12">operationID := req.GetOperationId()
        if operationID == "" </span><span class="cov4" title="3">{
                operationID = uuid.NewString()
        }</span>

        <span class="cov8" title="12">err = i.store.Credit(ctx, account.AccountID, req.GetAmount(), operationID)
        if err != nil </span><span class="cov4" title="3">{
                return &amp;desc.CreditResponse{
                        Status: desc.OperationStatus_STATUS_FAIL,
                }, status.Error(codes.Internal, fmt.Sprintf("Credit process err: %v", err))
        }</span>

        <span class="cov7" title="9">return &amp;desc.CreditResponse{
                Status: desc.OperationStatus_STATUS_OK,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package wallet

import (
        context "context"
        "fmt"

        "github.com/google/uuid"
        "gitlab.ozon.dev/route256/wallet/internal/config"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// Debit поступление денег
func (i *Implementation) Debit(ctx context.Context, req *desc.DebitRequest) (*desc.DebitResponse, error) <span class="cov10" title="27">{
        if err := i.CheckToken(ctx, req.UserId); err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="24">user, err := i.User(ctx, req.UserId)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>
        <span class="cov9" title="21">account, ok := user.GetAccount(req.GetAccountId())
        if !ok </span><span class="cov4" title="3">{
                return nil, status.Error(codes.NotFound, "account not found")
        }</span>

        <span class="cov8" title="18">if user.Level == config.ANON &amp;&amp; account.Amount+req.GetAmount() &gt; config.MaxAnonAmount </span><span class="cov0" title="0">{
                return &amp;desc.DebitResponse{
                        Status: desc.OperationStatus_STATUS_FAIL,
                }, status.Error(codes.InvalidArgument, "unavailable operation")
        }</span>

        <span class="cov8" title="18">if user.Level == config.FULL &amp;&amp; account.Amount+req.GetAmount() &gt; config.MaxFullAmount </span><span class="cov4" title="3">{
                return &amp;desc.DebitResponse{
                        Status: desc.OperationStatus_STATUS_FAIL,
                }, status.Error(codes.InvalidArgument, "unavailable operation")
        }</span>

        <span class="cov8" title="15">operationID := req.GetOperationId()
        if operationID == "" </span><span class="cov4" title="3">{
                operationID = uuid.NewString()
        }</span>
        <span class="cov8" title="15">err = i.store.Debit(ctx, req.GetAccountId(), req.GetAmount(), operationID)
        if err != nil </span><span class="cov5" title="6">{
                return &amp;desc.DebitResponse{
                        Status: desc.OperationStatus_STATUS_FAIL,
                }, status.Error(codes.Internal, fmt.Sprintf("Debit process err: %v", err))
        }</span>

        <span class="cov7" title="9">return &amp;desc.DebitResponse{
                Status: desc.OperationStatus_STATUS_OK,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package wallet

import (
        "context"

        "gitlab.ozon.dev/route256/wallet/internal/pkg/worker"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
)

// ForceCollectOperation Подсчет колличества операций
func (i *Implementation) ForceCollectOperation(_ context.Context, _ *desc.OperationCountRequest) (*desc.ForceOperationCountResponse, error) <span class="cov10" title="3">{
        worker.ForceSignal &lt;- struct{}{}
        return &amp;desc.ForceOperationCountResponse{}, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package wallet

import (
        context "context"

        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// GetAccountBalance получить инфу по балансу счета
func (i *Implementation) GetAccountBalance(ctx context.Context, req *desc.GetAccountBalanceRequest) (*desc.AccountBalanceResponse, error) <span class="cov10" title="24">{
        if err := i.CheckToken(ctx, req.UserId); err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="21">user, err := i.User(ctx, req.UserId)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="18">account, ok := user.GetAccount(req.GetAccountId())
        if !ok </span><span class="cov4" title="3">{
                return nil, status.Error(codes.NotFound, "account not found")
        }</span>

        <span class="cov8" title="15">return &amp;desc.AccountBalanceResponse{
                AccountId: account.AccountID,
                Amount:    account.Amount,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package wallet

import (
        context "context"
        "time"

        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// GetExchangeRates получить курсы валют
func (i *Implementation) GetExchangeRates(ctx context.Context, req *desc.GetExchangeRatesRequest) (*desc.GetExchangeRatesResponse, error) <span class="cov10" title="9">{
        date, err := time.Parse("02/01/2006", req.GetDate())
        if err != nil </span><span class="cov5" title="3">{
                return nil, status.Errorf(codes.InvalidArgument, "date must be like pattern MM/DD/YYYY")
        }</span>

        <span class="cov8" title="6">valutes, err := i.cbrClient.GetExchangeRates(ctx, date)
        if err != nil </span><span class="cov5" title="3">{
                return nil, status.Errorf(codes.Internal, "can not get valutes from cbr.ru: %v", err)
        }</span>

        <span class="cov5" title="3">var rates []*desc.GetExchangeRatesResponse_ExchangeRate
        for _, valute := range valutes.ValCurs </span><span class="cov8" title="6">{
                rates = append(rates, &amp;desc.GetExchangeRatesResponse_ExchangeRate{
                        Code:  valute.CharCode,
                        Value: valute.Value,
                        Name:  valute.Name,
                })
        }</span>

        <span class="cov5" title="3">return &amp;desc.GetExchangeRatesResponse{Rates: rates}, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package wallet

import (
        "context"
        "errors"
        "fmt"

        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (i *Implementation) GetUser(ctx context.Context, req *desc.GetUserRequest) (*desc.GetUserResponse, error) <span class="cov10" title="9">{
        if err := i.CheckToken(ctx, req.UserId); err != nil </span><span class="cov8" title="6">{
                return nil, err
        }</span>

        <span class="cov5" title="3">user, err := i.store.GetUser(ctx, req.UserId)
        if errors.Is(err, fmt.Errorf("account not found")) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "user not found")
        }</span>

        <span class="cov5" title="3">return &amp;desc.GetUserResponse{
                Info: &amp;desc.User{
                        Id:                  user.ID.String(),
                        Name:                user.Name,
                        Lastname:            user.Lastname,
                        Age:                 user.Age,
                        Phone:               user.Phone,
                        IdentificationLevel: desc.IdentificationLevel(desc.IdentificationLevel_value[user.Level]),
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package wallet

import (
        "context"

        "github.com/segmentio/kafka-go"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/protobuf/encoding/protojson"
)

func (i *Implementation) Consume(_ context.Context, req *desc.ConsumeRequest) (*desc.ConsumeResponse, error) <span class="cov5" title="3">{
        operations := make([]*desc.KafkaOperation, 0, req.GetCount())
        for _, consumedMsg := range i.kafka.GetConsumedMessages().Get(int(req.GetCount())) </span><span class="cov5" title="3">{
                operation, err := convertKafkaMessagesToProto(consumedMsg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov5" title="3">operations = append(operations, operation)</span>
        }

        <span class="cov5" title="3">return &amp;desc.ConsumeResponse{
                Operations: operations,
        }, nil</span>
}

func convertKafkaMessagesToProto(msg kafka.Message) (*desc.KafkaOperation, error) <span class="cov10" title="9">{
        operation := new(desc.KafkaOperation)
        err := protojson.Unmarshal(msg.Value, operation)
        if err != nil </span><span class="cov5" title="3">{
                return nil, err
        }</span>

        <span class="cov8" title="6">return operation, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package wallet

import (
        "context"

        "github.com/google/uuid"
        "github.com/segmentio/kafka-go"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/encoding/protojson"
)

func (i *Implementation) Produce(ctx context.Context, req *desc.ProduceRequest) (*desc.ProduceResponse, error) <span class="cov10" title="18">{
        err := validateProduceRequest(req)
        if err != nil </span><span class="cov9" title="15">{
                return nil, err
        }</span>

        <span class="cov4" title="3">reqB, err := protojson.Marshal(req.GetOperation())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="3">err = i.kafka.ProduceMessages(ctx, kafka.Message{Value: reqB})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="3">return &amp;desc.ProduceResponse{}, nil</span>
}

func validateProduceRequest(req *desc.ProduceRequest) error <span class="cov10" title="18">{
        if req.Operation == nil </span><span class="cov4" title="3">{
                return status.Errorf(codes.InvalidArgument, "operation must bu required")
        }</span>

        <span class="cov9" title="15">operation := req.GetOperation()

        if operation.GetOperationType() == desc.OperationType_TYPE_UNDEFINED </span><span class="cov4" title="3">{
                return status.Errorf(codes.InvalidArgument, "operationType: %s should not be empty", operation.GetOperationType())
        }</span>

        <span class="cov8" title="12">if operation.GetAmount() &lt; 0 </span><span class="cov4" title="3">{
                return status.Errorf(codes.InvalidArgument, "amount: %d should be more than 0", operation.GetAmount())
        }</span>

        <span class="cov7" title="9">_, err := uuid.Parse(operation.GetAccountId())
        if err != nil </span><span class="cov4" title="3">{
                return status.Errorf(codes.InvalidArgument, "accountID: %s should have UUID format", operation.GetAccountId())
        }</span>

        <span class="cov6" title="6">_, err = uuid.Parse(operation.GetExternalId())
        if err != nil </span><span class="cov4" title="3">{
                return status.Errorf(codes.InvalidArgument, "externalID: %s should have UUID format", operation.GetExternalId())
        }</span>

        <span class="cov4" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package wallet

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/utils"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (i *Implementation) LogIn(ctx context.Context, req *desc.LogInRequest) (*desc.LogInResponse, error) <span class="cov10" title="12">{
        ok := phonePattern.MatchString(req.Phone)
        if !ok </span><span class="cov4" title="3">{
                return nil, status.Error(codes.InvalidArgument, "phone not match pattern 8xxxxxxxxxx")
        }</span>

        <span class="cov8" title="9">user, err := i.store.GetUserByPhone(ctx, req.Phone)
        if errors.Is(err, fmt.Errorf("account not found")) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "user not found")
        }</span>

        <span class="cov8" title="9">if utils.GetPasswordHash(req.Password) != user.PasswordHash </span><span class="cov4" title="3">{
                return nil, status.Error(codes.InvalidArgument, "ivalid password") // Опечатка в invalid
        }</span>

        <span class="cov7" title="6">token := uuid.NewString()
        err = i.store.LogIn(ctx, user.ID.String(), token)
        if err != nil </span><span class="cov4" title="3">{
                return nil, status.Error(codes.Internal, "cannot login")
        }</span>

        <span class="cov4" title="3">return &amp;desc.LogInResponse{
                Token: token,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package wallet

import (
        "context"
        "errors"
        "fmt"

        "gitlab.ozon.dev/route256/wallet/internal/config"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (i *Implementation) UpgradeUser(ctx context.Context, req *desc.UpgradeUserRequest) (*desc.UpgradeUserResponse, error) <span class="cov10" title="21">{
        if err := i.CheckToken(ctx, req.UserId); err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="18">user, err := i.store.GetUser(ctx, req.UserId)
        if errors.Is(err, fmt.Errorf("account not found")) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "user not found")
        }</span>

        <span class="cov9" title="18">if user.Level == config.FULL </span><span class="cov4" title="3">{
                return nil, status.Error(codes.AlreadyExists, "user allready has FULL level")
        }</span>
        <span class="cov9" title="15">err = i.store.UpgradeUser(ctx, req.UserId, "FULL")
        if err != nil </span><span class="cov4" title="3">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("UpgradeUser err: %v", err))
        }</span>

        <span class="cov8" title="12">return &amp;desc.UpgradeUserResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cbr

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "time"

        "gitlab.ozon.dev/route256/wallet/internal/pkg/cbr/valutes"
)

func NewClient(cbrURL string) *Client <span class="cov10" title="9">{
        return &amp;Client{
                httpClient: &amp;http.Client{},
                cbrURL:     cbrURL,
        }
}</span>

type Client struct {
        httpClient *http.Client
        cbrURL     string
}

func (c *Client) GetExchangeRates(ctx context.Context, date time.Time) (*valutes.ValCurs, error) <span class="cov8" title="6">{
        if c.cbrURL == "" </span><span class="cov0" title="0">{
                return nil, errors.New("can not get rates: cbrURL not defined, check environment CBR_URL")
        }</span>

        <span class="cov8" title="6">req, err := http.NewRequestWithContext(ctx, http.MethodGet, c.cbrURL+"/scripts/XML_daily.asp", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can not create request error: %v", err)
        }</span>

        <span class="cov8" title="6">if date.IsZero() </span><span class="cov0" title="0">{
                date = time.Now()
        }</span>
        <span class="cov8" title="6">q := req.URL.Query()
        q.Add("date_req", date.Format("02/01/2006"))
        req.URL.RawQuery = q.Encode()

        req.Header.Add("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36")

        fmt.Println(req.URL.String())

        response, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request to cbr error: %v", err)
        }</span>

        <span class="cov8" title="6">return valutes.Unmarshal(response.Body)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package valutes

import (
        "encoding/xml"
        "io"

        "golang.org/x/text/encoding/charmap"
)

type ValCurs struct {
        ValCurs []Valute `xml:"Valute"`
}

type Valute struct {
        CharCode string `xml:"CharCode"`
        Name     string `xml:"Name"`
        Value    string `xml:"Value"`
}

func (v *ValCurs) Decode(r io.Reader) error <span class="cov10" title="6">{
        d := xml.NewDecoder(r)
        d.CharsetReader = func(_ string, input io.Reader) (io.Reader, error) </span><span class="cov0" title="0">{
                return charmap.Windows1251.NewDecoder().Reader(input), nil
        }</span>
        <span class="cov10" title="6">return d.Decode(v)</span>
}

func Unmarshal(r io.Reader) (*ValCurs, error) <span class="cov10" title="6">{
        v := &amp;ValCurs{}
        return v, v.Decode(r)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

// User информация о счете
type User struct {
        ID           uuid.UUID `db:"id"`
        Name         string    `db:"name"`
        Lastname     string    `db:"lastname"`
        Age          int32     `db:"age"`
        Phone        string    `db:"phone"`
        PasswordHash string    `db:"password_hash"`
        Level        string    `db:"level"`
        CreatedAt    time.Time `db:"created_at"`
}

type UserWithAccounts struct {
        User
        RawPassword string
        Accounts    []*Account
}

func (u *UserWithAccounts) GetAccount(accountID string) (*Account, bool) <span class="cov10" title="60">{
        for _, account := range u.Accounts </span><span class="cov9" title="51">{
                if account.AccountID == accountID </span><span class="cov9" title="51">{
                        return account, true
                }</span>
        }
        <span class="cov5" title="9">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package kafka

import (
        "context"
        "time"

        "github.com/rs/zerolog/log"
        "github.com/segmentio/kafka-go"
        "gitlab.ozon.dev/route256/wallet/internal/config"
        "golang.org/x/sync/errgroup"
)

type Client struct {
        writer *kafka.Writer
        reader *kafka.Reader

        consumeTick      time.Duration
        ConsumedMessages *MessageStore
}

type KafkaClient interface {
        ProduceMessages(ctx context.Context, messages ...kafka.Message) error
        ConsumeMessages(ctx context.Context)
        GetConsumedMessages() *MessageStore
}

func (c *Client) GetConsumedMessages() *MessageStore <span class="cov0" title="0">{
        return c.ConsumedMessages
}</span>

func NewClient(config config.Kafka) *Client <span class="cov0" title="0">{
        return &amp;Client{
                ConsumedMessages: NewMessageStore(1000),
                consumeTick:      config.ConsumeTicker,
                writer: &amp;kafka.Writer{
                        Addr:                   kafka.TCP(config.Hosts...),
                        Topic:                  config.Topic,
                        AllowAutoTopicCreation: true,
                },
                reader: kafka.NewReader(kafka.ReaderConfig{
                        Brokers:   config.Hosts,
                        Topic:     config.Topic,
                        Partition: 0,
                        MaxBytes:  10e6, // 10MB
                }),
        }
}</span>

func (c *Client) ProduceMessages(ctx context.Context, messages ...kafka.Message) error <span class="cov0" title="0">{
        return c.writer.WriteMessages(ctx, messages...)
}</span>

func (c *Client) ConsumeMessages(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(c.consumeTick)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        msg, err := c.reader.ReadMessage(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msgf("error reading message")
                                continue</span>
                        }

                        <span class="cov0" title="0">c.ConsumedMessages.Store(msg)
                        log.Info().Msgf("message at offset %d: %s = %s", msg.Offset, string(msg.Key), string(msg.Value))</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (c *Client) Stop() error <span class="cov0" title="0">{
        eg := errgroup.Group{}

        eg.Go(c.writer.Close)
        eg.Go(c.reader.Close)

        return eg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package kafka

import (
        "sync"

        "github.com/segmentio/kafka-go"
)

type MessageStore struct {
        mu               *sync.Mutex
        maxLimit         int
        consumedMessages []kafka.Message
}

func NewMessageStore(maxLimit int) *MessageStore <span class="cov10" title="9">{
        return &amp;MessageStore{
                mu:               &amp;sync.Mutex{},
                maxLimit:         maxLimit,
                consumedMessages: make([]kafka.Message, 0),
        }
}</span>

func (m *MessageStore) Store(message kafka.Message) <span class="cov10" title="9">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.consumedMessages = append(m.consumedMessages, message)
}</span>

func (m *MessageStore) Get(limit int) []kafka.Message <span class="cov10" title="9">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if len(m.consumedMessages) &gt; limit </span><span class="cov0" title="0">{
                return m.consumedMessages[:limit]
        }</span>
        <span class="cov10" title="9">return m.consumedMessages</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package storage

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/jmoiron/sqlx"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
)

const AccountNotFound = "account not found"

func (s *storage) AddAccount(ctx context.Context, account *domain.Account) error <span class="cov7" title="51">{
        stmt := s.Builder().Insert("accounts").
                Columns("user_id", "account_id", "amount", "description").
                Values(account.UserID, account.AccountID, account.Amount, account.Description).
                Suffix("RETURNING id")

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="51">err = s.db.GetContext(ctx, &amp;account.ID, req, args...)

        return err</span>
}

func (s *storage) GetAccount(ctx context.Context, accountID string) (*domain.Account, error) <span class="cov6" title="21">{
        var balance domain.Account

        stmt := s.Builder().Select("*").
                From("accounts").
                Where("account_id = ?", accountID)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="21">err = s.db.GetContext(ctx, &amp;balance, req, args...)

        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(AccountNotFound)
        }</span>
        <span class="cov6" title="21">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="21">return &amp;balance, nil</span>
}

func (s *storage) GetUserAccounts(ctx context.Context, userID string) ([]*domain.Account, error) <span class="cov10" title="189">{
        var accounts []*domain.Account

        stmt := s.Builder().Select("*").
                From("accounts").
                Where("user_id = ?", userID)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="189">err = s.db.SelectContext(ctx, &amp;accounts, req, args...)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return []*domain.Account{}, nil
        }</span>
        <span class="cov10" title="189">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="189">return accounts, nil</span>
}

func (s *storage) changeAccountAmount(ctx context.Context, db *sqlx.Tx, accountID string, newAmount int32) error <span class="cov5" title="18">{
        stmt := s.Builder().
                Update("accounts").
                Set("amount", newAmount).
                Where("account_id = ?", accountID)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="18">_, err = db.ExecContext(ctx, req, args...)

        return err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package storage

import (
        "context"
        "fmt"

        "github.com/jmoiron/sqlx"
        "github.com/rs/zerolog/log"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
)

func (s *storage) Credit(ctx context.Context, accountID string, amount int32, operationID string) error <span class="cov6" title="9">{
        err := s.AddAccountOperation(ctx, &amp;domain.AccountOperation{
                AccountID:     accountID,
                Amount:        amount,
                OperationID:   operationID,
                OperationType: domain.OperationTypeCredit,
        })
        return err
}</span>

func (s *storage) Debit(ctx context.Context, accountID string, amount int32, operationID string) error <span class="cov7" title="12">{
        err := s.AddAccountOperation(ctx, &amp;domain.AccountOperation{
                AccountID:     accountID,
                Amount:        amount,
                OperationID:   operationID,
                OperationType: domain.OperationTypeDebit,
        })
        return err
}</span>

func (s *storage) AddAccountOperation(ctx context.Context, operation *domain.AccountOperation) error <span class="cov9" title="21">{
        balance, err := s.GetAccount(ctx, operation.AccountID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't get account balance for change amount: %w", err)
        }</span>

        <span class="cov9" title="21">err = s.DoInTransaction(ctx, s.db, func(ctx context.Context, tx *sqlx.Tx) error </span><span class="cov9" title="21">{
                err = s.addAccountOperation(ctx, tx, operation)
                if err != nil </span><span class="cov3" title="3">{
                        return err
                }</span>

                <span class="cov8" title="18">newAccountAmount := balance.Amount + (int32(operation.OperationType) * operation.Amount)
                err = s.changeAccountAmount(ctx, tx, operation.AccountID, newAccountAmount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="18">return nil</span>
        })

        <span class="cov9" title="21">return err</span>
}

func (s *storage) addAccountOperation(ctx context.Context, db *sqlx.Tx, operation *domain.AccountOperation) error <span class="cov9" title="21">{
        stmt := s.Builder().Insert("account_operations").
                Columns("account_id, amount, operation_id", "operation_type").
                Values(operation.AccountID, operation.Amount, operation.OperationID, operation.OperationType).
                Suffix("RETURNING id")

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="21">err = db.GetContext(ctx, &amp;operation.ID, req, args...)

        return err</span>
}

func (s *storage) GetAccountOperations(ctx context.Context, accountID string, limit uint64) ([]domain.AccountOperation, error) <span class="cov10" title="30">{
        var operations []domain.AccountOperation

        stmt := s.Builder().Select("*").
                From("account_operations").
                Where("account_id = ?", accountID).
                OrderBy("created_at").
                Limit(limit)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="30">err = s.db.SelectContext(ctx, &amp;operations, req, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="30">return operations, nil</span>
}

func (s *storage) CollectOperation(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var count int64

        err := s.db.GetContext(ctx, &amp;count, "SELECT COUNT(*)  FROM account_operations")

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("error scanning account_operations table")
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package storage

import (
        "context"
        "database/sql"
        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/jmoiron/sqlx"
        "github.com/rs/zerolog/log"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
)

// Storage - интерфейс для работы с бд
type Storage interface {
        CreateUser(ctx context.Context, user *domain.User) error
        UpgradeUser(ctx context.Context, userID string, level string) error
        GetUser(ctx context.Context, userID string) (*domain.UserWithAccounts, error)
        GetUserSessions(ctx context.Context, userID string) ([]string, error)
        GetUserByPhone(ctx context.Context, phone string) (*domain.User, error)
        LogIn(ctx context.Context, userID string, token string) error

        CollectOperation(ctx context.Context) (int64, error)
        AddAccount(ctx context.Context, account *domain.Account) error
        GetAccount(ctx context.Context, accountID string) (*domain.Account, error)
        Debit(ctx context.Context, accountID string, amount int32, operationID string) error
        Credit(ctx context.Context, accountID string, amount int32, operationID string) error
        GetAccountOperations(ctx context.Context, accountID string, limit uint64) ([]domain.AccountOperation, error)

        Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
}

type storage struct {
        db *sqlx.DB
}

// New .
func New(db *sqlx.DB) Storage <span class="cov1" title="1">{
        return &amp;storage{
                db: db,
        }
}</span>

// Builder вернет squirrel SQL Builder объект
func (s *storage) Builder() sq.StatementBuilderType <span class="cov10" title="861">{
        return sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
}</span>

func (s *storage) DoInTransaction(ctx context.Context, db *sqlx.DB, fn func(ctx context.Context, tx *sqlx.Tx) error) (err error) <span class="cov5" title="21">{

        tx, err := db.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't begin transaction: %w", err)
        }</span>

        <span class="cov5" title="21">defer func() </span><span class="cov5" title="21">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        rollbackTx(ctx, tx)
                }</span> else<span class="cov5" title="21"> if err != nil </span><span class="cov2" title="3">{
                        rollbackTx(ctx, tx)
                }</span> else<span class="cov4" title="18"> {
                        if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("cannot commit transaction: %w", err)
                        }</span>
                }
        }()

        <span class="cov5" title="21">err = fn(ctx, tx)

        return err</span>
}

func rollbackTx(_ context.Context, tx *sqlx.Tx) <span class="cov2" title="3">{
        if err := tx.Rollback(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("sqltx/rollbackTx: cannot rollback transaction")
        }</span>
}

func (s *storage) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov2" title="3">{
        return s.db.ExecContext(ctx, query, args...)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package storage

import (
        "context"
        "database/sql"
        "fmt"

        "gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
)

func (s *storage) CreateUser(ctx context.Context, user *domain.User) error <span class="cov9" title="108">{
        stmt := s.Builder().Insert("users").
                Columns("name", "lastname", "age", "phone", "password_hash", "level").
                Values(user.Name, user.Lastname, user.Age, user.Phone, user.PasswordHash, user.Level).
                Suffix("RETURNING id")

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="108">err = s.db.GetContext(ctx, &amp;user.ID, req, args...)

        return err</span>
}

func (s *storage) UpgradeUser(ctx context.Context, userID string, level string) error <span class="cov5" title="12">{
        stmt := s.Builder().
                Update("users").
                Set("level", level).
                Where("id = ?", userID)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="12">_, err = s.db.ExecContext(ctx, req, args...)

        return err</span>
}

func (s *storage) LogIn(ctx context.Context, userID, token string) error <span class="cov9" title="108">{
        stmt := s.Builder().
                Insert("sessions").
                Columns("user_id", "token").
                Values(userID, token)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="108">_, err = s.db.ExecContext(ctx, req, args...)

        return err</span>
}

func (s *storage) GetUser(ctx context.Context, userID string) (*domain.UserWithAccounts, error) <span class="cov10" title="189">{
        user, err := s.getUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="189">accounts, err := s.GetUserAccounts(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="189">return &amp;domain.UserWithAccounts{
                User:     *user,
                Accounts: accounts,
        }, nil</span>
}

func (s *storage) getUser(ctx context.Context, userID string) (*domain.User, error) <span class="cov10" title="189">{
        var user domain.User

        stmt := s.Builder().
                Select("*").
                From("users").
                Where("id = ?", userID)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="189">err = s.db.GetContext(ctx, &amp;user, req, args...)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>
        <span class="cov10" title="189">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="189">return &amp;user, nil</span>
}

func (s *storage) GetUserByPhone(ctx context.Context, phone string) (*domain.User, error) <span class="cov4" title="9">{
        var user domain.User

        stmt := s.Builder().
                Select("*").
                From("users").
                Where("phone = ?", phone)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="9">err = s.db.GetContext(ctx, &amp;user, req, args...)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("account not found")
        }</span>
        <span class="cov4" title="9">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="9">return &amp;user, nil</span>
}

func (s *storage) GetUserSessions(ctx context.Context, userID string) ([]string, error) <span class="cov8" title="105">{
        var tokens []string

        stmt := s.Builder().
                Select("token").
                From("sessions").
                Where("user_id = ?", userID)

        req, args, err := stmt.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="105">err = s.db.SelectContext(ctx, &amp;tokens, req, args...)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        <span class="cov8" title="105">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="105">return tokens, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package testutils

import (
        "context"
        "strings"

        "github.com/ddosify/go-faker/faker"
        "github.com/google/uuid"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/domain"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/storage"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/token"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/utils"
)

func CreateUserAndAuth(ctx context.Context, store storage.Storage, accounts ...*domain.Account) (context.Context, *domain.UserWithAccounts, error) <span class="cov10" title="105">{
        fake := faker.NewFaker()

        randomPhone := strings.Replace("8"+fake.RandomPhoneNumber(), "-", "", -1)

        password := fake.RandomPassword()
        user := &amp;domain.User{
                Name:         fake.RandomPersonFirstName(),
                Lastname:     fake.RandomPersonLastName(),
                Age:          int32(fake.RandomDigitNotNull()),
                Phone:        randomPhone,
                PasswordHash: utils.GetPasswordHash(password),
        }

        err := store.CreateUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, nil, err
        }</span>

        <span class="cov10" title="105">session := uuid.NewString()
        err = store.LogIn(ctx, user.ID.String(), session)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, nil, err
        }</span>

        <span class="cov10" title="105">for _, acc := range accounts </span><span class="cov7" title="36">{
                err = store.AddAccount(ctx, &amp;domain.Account{
                        UserID:      user.ID,
                        AccountID:   acc.AccountID,
                        Amount:      acc.Amount,
                        Description: acc.Description,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return ctx, nil, err
                }</span>
        }

        <span class="cov10" title="105">ctxWithToken := token.ToCtx(ctx, session)
        userDb, err := store.GetUser(ctx, user.ID.String())
        if err != nil </span><span class="cov0" title="0">{
                return ctx, nil, err
        }</span>
        <span class="cov10" title="105">userDb.RawPassword = password

        return ctxWithToken, userDb, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package token

import (
        "context"

        "github.com/samber/lo"
        "google.golang.org/grpc/metadata"
)

// nolint
const (
        HeaderKey = "Authorization"
        Key       = "authorization"
)

func Check(ctx context.Context, sessions []string) bool <span class="cov10" title="120">{
        session, ok := FromCtx(ctx)
        if !ok </span><span class="cov6" title="15">{
                return false
        }</span>

        <span class="cov9" title="105">return lo.Contains(sessions, session)</span>
}

func ToCtx(ctx context.Context, session string) context.Context <span class="cov9" title="105">{
        ctx = metadata.NewOutgoingContext(ctx, metadata.New(map[string]string{
                Key: session,
        }))
        ctx = metadata.NewIncomingContext(ctx, metadata.New(map[string]string{
                Key: session,
        }))
        return ctx
}</span>

func FromCtx(ctx context.Context) (string, bool) <span class="cov10" title="120">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov6" title="15">{
                return "", false
        }</span>
        <span class="cov9" title="105">res := md.Get(Key)
        if len(res) == 0 </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov9" title="105">return res[0], true</span>
}

func FromCtxToRequest(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        md, ok := metadata.FromOutgoingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">res := md.Get(Key)
        if len(res) == 0 </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return res[0], true</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import (
        "crypto/sha1" //nolint:gosec
        "encoding/hex"
)

func GetPasswordHash(password string) string <span class="cov10" title="120">{
        h := sha1.New() //nolint:gosec
        h.Write([]byte(password))
        return hex.EncodeToString(h.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package worker

import (
        "context"
        "sync/atomic"
        "time"

        "github.com/rs/zerolog/log"
        "gitlab.ozon.dev/route256/wallet/internal/config"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/storage"
)

var (
        // Count .
        Count atomic.Int64
        // ForceSignal .
        ForceSignal = make(chan struct{})
)

type Collect struct{}

func NewCollect() *Collect <span class="cov0" title="0">{
        return &amp;Collect{}
}</span>

func (c *Collect) Start(ctx context.Context, repo storage.Storage, conf *config.AppConfig) <span class="cov0" title="0">{
        ticker := time.NewTicker(conf.Jobs.DurationCollectOperation)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">

                        count, err := repo.CollectOperation(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("failed to collect operation")
                        }</span>

                        <span class="cov0" title="0">log.Info().Msgf("%d all operations collected", count)

                        old := Count.Swap(count)

                        log.Info().Msgf("%d old operations collected", old)</span>
                case &lt;-ForceSignal:<span class="cov0" title="0">
                        log.Info().Msgf("Start force collect operation")
                        count, err := repo.CollectOperation(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("failed to collect operation")
                        }</span>

                        <span class="cov0" title="0">log.Info().Msgf("%d all operations collected", count)

                        Count.Swap(count)</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        ticker.Stop()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "gitlab.ozon.dev/route256/wallet/internal/config"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func createGatewayServer(ctx context.Context, cfg *config.AppConfig) (*http.Server, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(
                cfg.Grpc.Addr,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to dial server: %w", err)
        }</span>

        <span class="cov0" title="0">mux := runtime.NewServeMux()

        if err := desc.RegisterWalletHandler(ctx, mux, conn); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed registration handler: %w", err)
        }</span>

        //nolint:gosec
        <span class="cov0" title="0">gatewayServer := &amp;http.Server{
                Addr:    cfg.Rest.Addr,
                Handler: mux,
        }

        return gatewayServer, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package server

import (
        "context"

        "github.com/rs/zerolog/log"
        "google.golang.org/grpc"
)

func loggingInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (_ interface{}, err error) </span><span class="cov0" title="0">{
                log.Debug().Msgf("%s.Request: %+v", info.FullMethod, req)
                res, err := handler(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("%s.Error: %+v", info.FullMethod, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Debug().Msgf("%s.Response: %+v", info.FullMethod, res)
                }</span>
                <span class="cov0" title="0">return res, err</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package server

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
        "gitlab.ozon.dev/route256/wallet/internal/config"
)

func createMetricsServer(cfg config.Metrics) *http.Server <span class="cov0" title="0">{
        mux := http.DefaultServeMux
        mux.Handle(cfg.Path, promhttp.Handler())

        //nolint:gosec
        metricsServer := &amp;http.Server{
                Addr:    cfg.Addr,
                Handler: mux,
        }

        return metricsServer
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"
        "sync/atomic"
        "syscall"
        "time"

        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpcrecovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
        grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/jmoiron/sqlx"
        "github.com/rs/zerolog/log"
        wallet "gitlab.ozon.dev/route256/wallet/internal/app/wallet"
        "gitlab.ozon.dev/route256/wallet/internal/config"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/kafka"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/storage"
        "gitlab.ozon.dev/route256/wallet/internal/pkg/worker"
        desc "gitlab.ozon.dev/route256/wallet/pkg/api/wallet"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

// Server .
type Server struct {
        db *sqlx.DB
}

// NewServer .
func NewServer(db *sqlx.DB) *Server <span class="cov0" title="0">{
        return &amp;Server{
                db: db,
        }
}</span>

// Start method runs server
func (s *Server) Start(cfg *config.AppConfig) error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        gatewayServer, err := createGatewayServer(ctx, cfg)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed create gateway server")
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info().Msgf("Gateway server is running on %s", cfg.Rest.Addr)
                if err = gatewayServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed running gateway server")
                        cancel()
                }</span>
        }()

        <span class="cov0" title="0">metricsServer := createMetricsServer(cfg.Metrics)
        go func() </span><span class="cov0" title="0">{
                log.Info().Msgf("Metrics server is running on %s", cfg.Metrics.Addr)
                if err = metricsServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed running metrics server")
                        cancel()
                }</span>
        }()

        <span class="cov0" title="0">isReady := &amp;atomic.Value{}
        isReady.Store(false)

        statusServer := createStatusServer(cfg.Status, isReady)
        go func() </span><span class="cov0" title="0">{
                log.Info().Msgf("Status server is running on %s", cfg.Status.Addr)
                if err = statusServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed running status server")
                }</span>
        }()

        <span class="cov0" title="0">l, err := net.Listen("tcp", cfg.Grpc.Addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %w", err)
        }</span>
        <span class="cov0" title="0">defer l.Close()

        grpcServer := grpc.NewServer(
                grpc.KeepaliveParams(cfg.Grpc.ServerParameters),
                grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
                        grpc_ctxtags.UnaryServerInterceptor(),
                        grpc_prometheus.UnaryServerInterceptor,
                        loggingInterceptor(),
                        grpcrecovery.UnaryServerInterceptor(),
                )),
        )

        repo := storage.New(s.db)
        collect := worker.NewCollect()

        kfk := kafka.NewClient(cfg.Kafka)
        go kfk.ConsumeMessages(ctx)

        desc.RegisterWalletServer(grpcServer, wallet.NewWallet(repo, kfk))
        grpc_prometheus.EnableHandlingTimeHistogram()
        grpc_prometheus.Register(grpcServer)

        go collect.Start(ctx, repo, cfg)

        go func() </span><span class="cov0" title="0">{
                log.Info().Msg("Turn on reflection.Register")
                reflection.Register(grpcServer)

                log.Info().Msgf("GRPC Server is listening on: %s", cfg.Grpc.Addr)
                if err := grpcServer.Serve(l); err != nil </span><span class="cov0" title="0">{
                        cancel()
                        log.Fatal().Err(err).Msg("Failed running gRPC server")
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                time.Sleep(2 * time.Second)
                isReady.Store(true)
                log.Info().Msg("The service is ready to accept requests")
        }</span>()

        //graceful Shutdown
        <span class="cov0" title="0">{
                quit := make(chan os.Signal, 1)
                signal.Notify(quit, os.Interrupt, syscall.SIGTERM)

                select </span>{
                case v := &lt;-quit:<span class="cov0" title="0">
                        log.Info().Msgf("signal.Notify: %v", v)</span>
                case done := &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info().Msgf("ctx.Done: %v", done)</span>
                }

                <span class="cov0" title="0">if err := kfk.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to stop kafka server")
                }</span>
                <span class="cov0" title="0">isReady.Store(false)
                gracefulStop(ctx, grpcServer, gatewayServer, statusServer, metricsServer)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func gracefulStop(ctx context.Context, grpcServer *grpc.Server, gatewayServer, statusServer, metricsServer *http.Server) <span class="cov0" title="0">{
        if err := gatewayServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("gatewayServer.Shutdown")
        }</span> else<span class="cov0" title="0"> {
                log.Info().Msg("gatewayServer shut down correctly")
        }</span>

        <span class="cov0" title="0">if err := statusServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("statusServer.Shutdown")
        }</span> else<span class="cov0" title="0"> {
                log.Info().Msg("statusServer shut down correctly")
        }</span>

        <span class="cov0" title="0">if err := metricsServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("metricsServer.Shutdown")
        }</span> else<span class="cov0" title="0"> {
                log.Info().Msg("metricsServer shut down correctly")
        }</span>

        <span class="cov0" title="0">grpcServer.GracefulStop()
        log.Info().Msgf("grpcServer shut down correctly")</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package server

import (
        "net/http"
        "sync/atomic"

        "gitlab.ozon.dev/route256/wallet/internal/config"
)

func createStatusServer(cfg config.Status, isReady *atomic.Value) *http.Server <span class="cov0" title="0">{
        mux := http.DefaultServeMux

        mux.HandleFunc(cfg.LivenessPath, livenessHandler)
        mux.HandleFunc(cfg.ReadinessPath, readinessHandler(isReady))

        //nolint:gosec
        statusServer := &amp;http.Server{
                Addr:    cfg.Addr,
                Handler: mux,
        }

        return statusServer
}</span>

func livenessHandler(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
}</span>

func readinessHandler(isReady *atomic.Value) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                if isReady == nil || !isReady.Load().(bool) </span><span class="cov0" title="0">{
                        http.Error(w, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)

                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
